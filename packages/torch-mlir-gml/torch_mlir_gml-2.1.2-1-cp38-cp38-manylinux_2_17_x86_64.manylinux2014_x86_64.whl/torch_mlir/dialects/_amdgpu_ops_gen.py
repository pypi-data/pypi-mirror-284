
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _amdgpu_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "amdgpu"
  pass


@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class LDSBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.lds_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class MFMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.mfma"

  _ODS_REGIONS = (0, True)

  def __init__(self, destD, m, n, k, blocks, sourceA, sourceB, destC, *, cbsz=None, abid=None, blgp=None, reducePrecision=None, negateA=None, negateB=None, negateC=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sourceA))
    operands.append(_get_op_result_or_value(sourceB))
    operands.append(_get_op_result_or_value(destC))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["m"] = (m if (
    issubclass(type(m), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(m, context=_ods_context))
    attributes["n"] = (n if (
    issubclass(type(n), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(n, context=_ods_context))
    attributes["k"] = (k if (
    issubclass(type(k), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(k, context=_ods_context))
    attributes["blocks"] = (blocks if (
    issubclass(type(blocks), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(blocks, context=_ods_context))
    if cbsz is not None: attributes["cbsz"] = (cbsz if (
        issubclass(type(cbsz), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(cbsz, context=_ods_context))
    if abid is not None: attributes["abid"] = (abid if (
        issubclass(type(abid), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(abid, context=_ods_context))
    if blgp is not None: attributes["blgp"] = (blgp if (
        issubclass(type(blgp), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AMDGPU_MFMAPermBAttr')) else
          _ods_ir.AttrBuilder.get('AMDGPU_MFMAPermBAttr')(blgp, context=_ods_context))
    if bool(reducePrecision): attributes["reducePrecision"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateA): attributes["negateA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateB): attributes["negateB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(negateC): attributes["negateC"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(destD)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def m(self):
    return self.operation.attributes["m"]

  @m.setter
  def m(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["m"] = value

  @builtins.property
  def n(self):
    return self.operation.attributes["n"]

  @n.setter
  def n(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["n"] = value

  @builtins.property
  def k(self):
    return self.operation.attributes["k"]

  @k.setter
  def k(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["k"] = value

  @builtins.property
  def blocks(self):
    return self.operation.attributes["blocks"]

  @blocks.setter
  def blocks(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blocks"] = value

  @builtins.property
  def cbsz(self):
    return self.operation.attributes["cbsz"]

  @cbsz.setter
  def cbsz(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cbsz"] = value

  @builtins.property
  def abid(self):
    return self.operation.attributes["abid"]

  @abid.setter
  def abid(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["abid"] = value

  @builtins.property
  def blgp(self):
    return self.operation.attributes["blgp"]

  @blgp.setter
  def blgp(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["blgp"] = value

  @builtins.property
  def reducePrecision(self):
    return "reducePrecision" in self.operation.attributes

  @reducePrecision.setter
  def reducePrecision(self, value):
    if bool(value):
      self.operation.attributes["reducePrecision"] = _ods_ir.UnitAttr.get()
    elif "reducePrecision" in self.operation.attributes:
      del self.operation.attributes["reducePrecision"]

  @reducePrecision.deleter
  def reducePrecision(self):
    del self.operation.attributes["reducePrecision"]

  @builtins.property
  def negateA(self):
    return "negateA" in self.operation.attributes

  @negateA.setter
  def negateA(self, value):
    if bool(value):
      self.operation.attributes["negateA"] = _ods_ir.UnitAttr.get()
    elif "negateA" in self.operation.attributes:
      del self.operation.attributes["negateA"]

  @negateA.deleter
  def negateA(self):
    del self.operation.attributes["negateA"]

  @builtins.property
  def negateB(self):
    return "negateB" in self.operation.attributes

  @negateB.setter
  def negateB(self, value):
    if bool(value):
      self.operation.attributes["negateB"] = _ods_ir.UnitAttr.get()
    elif "negateB" in self.operation.attributes:
      del self.operation.attributes["negateB"]

  @negateB.deleter
  def negateB(self):
    del self.operation.attributes["negateB"]

  @builtins.property
  def negateC(self):
    return "negateC" in self.operation.attributes

  @negateC.setter
  def negateC(self, value):
    if bool(value):
      self.operation.attributes["negateC"] = _ods_ir.UnitAttr.get()
    elif "negateC" in self.operation.attributes:
      del self.operation.attributes["negateC"]

  @negateC.deleter
  def negateC(self):
    del self.operation.attributes["negateC"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferAtomicCmpswapOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_cmpswap"

  _ODS_OPERAND_SEGMENTS = [1,1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, src, cmp, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(src))
    operands.append(_get_op_result_or_value(cmp))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def src(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def cmp(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferAtomicFaddOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fadd"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferAtomicFmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_fmax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferAtomicSmaxOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_smax"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferAtomicUminOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_atomic_umin"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferLoadOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_load"

  _ODS_OPERAND_SEGMENTS = [1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    results.append(value)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

  @builtins.property
  def value(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class RawBufferStoreOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.raw_buffer_store"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, value, memref, indices, *, boundsCheck=None, indexOffset=None, sgprOffset=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(memref))
    operands.append(_get_op_results_or_values(indices))
    operands.append(_get_op_result_or_value(sgprOffset) if sgprOffset is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if boundsCheck is not None: attributes["boundsCheck"] = (boundsCheck if (
        issubclass(type(boundsCheck), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(boundsCheck, context=_ods_context))
    if indexOffset is not None: attributes["indexOffset"] = (indexOffset if (
        issubclass(type(indexOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(indexOffset, context=_ods_context))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def memref(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def indices(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def sgprOffset(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def boundsCheck(self):
    return self.operation.attributes["boundsCheck"]

  @boundsCheck.setter
  def boundsCheck(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["boundsCheck"] = value

  @builtins.property
  def indexOffset(self):
    if "indexOffset" not in self.operation.attributes:
      return None
    return self.operation.attributes["indexOffset"]

  @indexOffset.setter
  def indexOffset(self, value):
    if value is not None:
      self.operation.attributes["indexOffset"] = value
    elif "indexOffset" in self.operation.attributes:
      del self.operation.attributes["indexOffset"]

  @indexOffset.deleter
  def indexOffset(self):
    del self.operation.attributes["indexOffset"]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class WMMAOp(_ods_ir.OpView):
  OPERATION_NAME = "amdgpu.wmma"

  _ODS_REGIONS = (0, True)

  def __init__(self, destD, sourceA, sourceB, destC, *, subwordOffset=None, unsignedA=None, unsignedB=None, clamp=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(sourceA))
    operands.append(_get_op_result_or_value(sourceB))
    operands.append(_get_op_result_or_value(destC))
    _ods_context = _ods_get_default_loc_context(loc)
    if subwordOffset is not None: attributes["subwordOffset"] = (subwordOffset if (
        issubclass(type(subwordOffset), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(subwordOffset, context=_ods_context))
    if bool(unsignedA): attributes["unsignedA"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(unsignedB): attributes["unsignedB"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(clamp): attributes["clamp"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(destD)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def sourceA(self):
    return self.operation.operands[0]

  @builtins.property
  def sourceB(self):
    return self.operation.operands[1]

  @builtins.property
  def destC(self):
    return self.operation.operands[2]

  @builtins.property
  def subwordOffset(self):
    return self.operation.attributes["subwordOffset"]

  @subwordOffset.setter
  def subwordOffset(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["subwordOffset"] = value

  @builtins.property
  def unsignedA(self):
    return "unsignedA" in self.operation.attributes

  @unsignedA.setter
  def unsignedA(self, value):
    if bool(value):
      self.operation.attributes["unsignedA"] = _ods_ir.UnitAttr.get()
    elif "unsignedA" in self.operation.attributes:
      del self.operation.attributes["unsignedA"]

  @unsignedA.deleter
  def unsignedA(self):
    del self.operation.attributes["unsignedA"]

  @builtins.property
  def unsignedB(self):
    return "unsignedB" in self.operation.attributes

  @unsignedB.setter
  def unsignedB(self, value):
    if bool(value):
      self.operation.attributes["unsignedB"] = _ods_ir.UnitAttr.get()
    elif "unsignedB" in self.operation.attributes:
      del self.operation.attributes["unsignedB"]

  @unsignedB.deleter
  def unsignedB(self):
    del self.operation.attributes["unsignedB"]

  @builtins.property
  def clamp(self):
    return "clamp" in self.operation.attributes

  @clamp.setter
  def clamp(self, value):
    if bool(value):
      self.operation.attributes["clamp"] = _ods_ir.UnitAttr.get()
    elif "clamp" in self.operation.attributes:
      del self.operation.attributes["clamp"]

  @clamp.deleter
  def clamp(self):
    del self.operation.attributes["clamp"]

  @builtins.property
  def destD(self):
    return self.operation.results[0]
