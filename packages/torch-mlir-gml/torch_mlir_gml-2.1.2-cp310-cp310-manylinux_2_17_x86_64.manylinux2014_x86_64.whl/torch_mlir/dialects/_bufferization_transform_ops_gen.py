
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _bufferization_transform_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class BufferLoopHoistingOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.buffer_loop_hoisting"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EliminateEmptyTensorsOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.eliminate_empty_tensors"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class EmptyTensorToAllocTensorOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.empty_tensor_to_alloc_tensor"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class OneShotBufferizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.bufferization.one_shot_bufferize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, function_boundary_type_conversion=None, allow_return_allocs=None, allow_unknown_ops=None, bufferize_function_boundaries=None, create_deallocs=None, test_analysis_only=None, print_conflicts=None, memcpy_op=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    _ods_context = _ods_get_default_loc_context(loc)
    if function_boundary_type_conversion is not None: attributes["function_boundary_type_conversion"] = (function_boundary_type_conversion if (
        issubclass(type(function_boundary_type_conversion), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('LayoutMapOption')) else
          _ods_ir.AttrBuilder.get('LayoutMapOption')(function_boundary_type_conversion, context=_ods_context))
    if allow_return_allocs is not None: attributes["allow_return_allocs"] = (allow_return_allocs if (
        issubclass(type(allow_return_allocs), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_return_allocs, context=_ods_context))
    if allow_unknown_ops is not None: attributes["allow_unknown_ops"] = (allow_unknown_ops if (
        issubclass(type(allow_unknown_ops), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(allow_unknown_ops, context=_ods_context))
    if bufferize_function_boundaries is not None: attributes["bufferize_function_boundaries"] = (bufferize_function_boundaries if (
        issubclass(type(bufferize_function_boundaries), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(bufferize_function_boundaries, context=_ods_context))
    if create_deallocs is not None: attributes["create_deallocs"] = (create_deallocs if (
        issubclass(type(create_deallocs), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(create_deallocs, context=_ods_context))
    if test_analysis_only is not None: attributes["test_analysis_only"] = (test_analysis_only if (
        issubclass(type(test_analysis_only), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(test_analysis_only, context=_ods_context))
    if print_conflicts is not None: attributes["print_conflicts"] = (print_conflicts if (
        issubclass(type(print_conflicts), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(print_conflicts, context=_ods_context))
    if memcpy_op is not None: attributes["memcpy_op"] = (memcpy_op if (
        issubclass(type(memcpy_op), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(memcpy_op, context=_ods_context))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def function_boundary_type_conversion(self):
    if "function_boundary_type_conversion" not in self.operation.attributes:
      return None
    return self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.setter
  def function_boundary_type_conversion(self, value):
    if value is not None:
      self.operation.attributes["function_boundary_type_conversion"] = value
    elif "function_boundary_type_conversion" in self.operation.attributes:
      del self.operation.attributes["function_boundary_type_conversion"]

  @function_boundary_type_conversion.deleter
  def function_boundary_type_conversion(self):
    del self.operation.attributes["function_boundary_type_conversion"]

  @builtins.property
  def allow_return_allocs(self):
    return self.operation.attributes["allow_return_allocs"]

  @allow_return_allocs.setter
  def allow_return_allocs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_return_allocs"] = value

  @builtins.property
  def allow_unknown_ops(self):
    return self.operation.attributes["allow_unknown_ops"]

  @allow_unknown_ops.setter
  def allow_unknown_ops(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["allow_unknown_ops"] = value

  @builtins.property
  def bufferize_function_boundaries(self):
    return self.operation.attributes["bufferize_function_boundaries"]

  @bufferize_function_boundaries.setter
  def bufferize_function_boundaries(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["bufferize_function_boundaries"] = value

  @builtins.property
  def create_deallocs(self):
    return self.operation.attributes["create_deallocs"]

  @create_deallocs.setter
  def create_deallocs(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["create_deallocs"] = value

  @builtins.property
  def test_analysis_only(self):
    return self.operation.attributes["test_analysis_only"]

  @test_analysis_only.setter
  def test_analysis_only(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["test_analysis_only"] = value

  @builtins.property
  def print_conflicts(self):
    return self.operation.attributes["print_conflicts"]

  @print_conflicts.setter
  def print_conflicts(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["print_conflicts"] = value

  @builtins.property
  def memcpy_op(self):
    return self.operation.attributes["memcpy_op"]

  @memcpy_op.setter
  def memcpy_op(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memcpy_op"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]
