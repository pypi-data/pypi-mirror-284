from .util import num_tokens_from_messages
import autopipeline

def query_gen(user_query, tables, description, status, verbose, client, gpt4):
    messages = [
        {
            "role": "system",
            "content": 
            '''
            "Given a database with the following tables: ''' + tables 
            + '''. The detailed descriptions of the tables are as follows: ''' + description
            +
            '''Your task is to generate SQL code that 
            1. can be executed directly on the database in .sqlite format based on users' queries;
            2. the code should produce correct results based on the SAMPLE VALUES AND DESCRPITIONS of each column.''' + '''
            ATTENTION: the values are case-sensitive, and you should strictly follow their provided formats and sample values (if any).
            IMPORTANT: Return the PLAIN code snippets ONLY (DONOT output formatting stuffs like ```sql). You are not allowed to output anything else. 
            '''

        },
        {
            "role": "user",
            "content": '''Name movie titles released in year 1945. Sort the listing by the descending order of movie popularity. Specifically, released in the year 1945 refers to movie_release_year = 1945; 'table \'lists_users\' contains the following columns: column \'user_id\' contains ID related to the user who created the list. with data format being integer and value descriptions being nan; column \'list_id\' contains ID of the list on Mubi with data format being integer and value descriptions being nan; column \'list_update_date_utc\' contains Last update date for the list with data format being text and value descriptions being YYYY-MM-DD; column \'list_creation_date_utc\' contains Creation date for the list with data format being text and value descriptions being YYYY-MM-DD; column \'user_trialist\' contains whether the user was a tralist when he created the list  with data format being integer and value descriptions being 1 = the user was a trialist when he created the list\n 0 = the user was not a trialist when he created the list; column \'user_subscriber\' contains whether the user was a subscriber when he created the list  with data format being integer and value descriptions being 1 = the user was a subscriber when he created the list \n0 = the user was not a subscriber when he created the list; column \'user_avatar_image_url\' contains User profile image URL on Mubi with data format being text and value descriptions being nan; column \'user_cover_image_url\' contains User profile cover image URL on Mubi with data format being text and value descriptions being nan; column \'user_eligible_for_trial\' contains whether the user was eligible for trial when he created the list  with data format being text and value descriptions being 1 = the user was eligible for trial when he created the list \n0 = the user was not eligible for trial when he created the list; column \'user_has_payment_method \' contains whether the user was a paying subscriber when he created the list  with data format being text and value descriptions being 1 = the user was a paying subscriber when he created the list \n0 = the user was not a paying subscriber when he created the list ; table \'lists\' contains the following columns: column \'user_id\' contains ID related to the user who created the list. with data format being integer and value descriptions being nan; column \'list_id\' contains ID of the list on Mubi with data format being integer and value descriptions being nan; column \'list_title\' contains Name of the list with data format being text and value descriptions being nan; column \'list_movie_number\' contains Number of movies added to the list with data format being integer and value descriptions being nan; column \'list_update_timestamp_utc\' contains Last update timestamp for the list with data format being text and value descriptions being nan; column \'list_creation_timestamp_utc\' contains Creation timestamp for the list with data format being text and value descriptions being nan; column \'list_followers\' contains Number of followers on the list with data format being integer and value descriptions being nan; column \'list_url\' contains URL to the list page on Mubi with data format being text and value descriptions being nan; column \'list_comments\' contains Number of comments on the list with data format being integer and value descriptions being nan; column \'list_description\' contains List description made by the user with data format being text and value descriptions being nan; column \'list_cover_image_url\' contains nan with data format being nan and value descriptions being nan; column \'list_first_image_url\' contains nan with data format being nan and value descriptions being nan; column \'list_second_image_url\' contains nan with data format being nan and value descriptions being nan; column \'list_third_image_url\' contains nan with data format being nan and value descriptions being nan; table \'ratings\' contains the following columns: column \'movie_id\' contains Movie ID related to the rating with data format being integer and value descriptions being nan; column \'rating_id\' contains Rating ID on Mubi with data format being integer and value descriptions being nan; column \'rating_url\' contains URL to the rating on Mubi with data format being text and value descriptions being nan; column \'rating_score\' contains Rating score ranging from 1 (lowest) to 5 (highest) with data format being integer and value descriptions being commonsense evidence:\nThe score is proportional to the user\'s liking.\nThe higher the score is, the more the user likes the movie; column \'rating_timestamp_utc \' contains Timestamp for the movie rating made by the user on Mubi with data format being text and value descriptions being nan; column \'critic\' contains Critic made by the user rating the movie.  with data format being text and value descriptions being If value = "None", the user did not write a critic when rating the movie.; column \'critic_likes\' contains Number of likes related to the critic made by the user rating the movie with data format being integer and value descriptions being nan; column \'critic_comments\' contains Number of comments related to the critic made by the user rating the movie with data format being integer and value descriptions being nan; column \'user_id\' contains ID related to the user rating the movie with data format being integer and value descriptions being nan; column \'user_trialist \' contains whether user was a tralist when he rated the movie with data format being integer and value descriptions being 1 = the user was a trialist when he rated the movie \n0 = the user was not a trialist when he rated the movie; column \'user_subscriber\' contains nan with data format being integer and value descriptions being nan; column \'user_eligible_for_trial\' contains nan with data format being integer and value descriptions being nan; column \'user_has_payment_method\' contains nan with data format being integer and value descriptions being nan; table \'ratings_users\' contains the following columns: column \'user_id\' contains ID related to the user rating the movie with data format being integer and value descriptions being nan; column \'rating_date_utc\' contains Rating date for the movie rating. with data format being text and value descriptions being YYYY-MM-DD; column \'user_trialist\' contains whether the user was a trialist when he rated the movie with data format being integer and value descriptions being 1 = the user was a trialist when he rated the movie\n 0 = the user was not a trialist when he rated the movie; column \'user_subscriber\' contains whether the user was a subscriber when he rated the movie with data format being integer and value descriptions being 1 = the user was a subscriber when he rated the movie \n0 = the user was not a subscriber when he rated the movie; column \'user_avatar_image_url\' contains URL to the user profile image on Mubi with data format being text and value descriptions being nan; column \'user_cover_image_url\' contains URL to the user profile cover image on Mubi with data format being text and value descriptions being nan; column \'user_eligible_for_trial\' contains whether the user was eligible for trial when he rated the movie with data format being integer and value descriptions being 1 = the user was eligible for trial when he rated the movie\n 0 = the user was not eligible for trial when he rated the movie; column \'user_has_payment_method \' contains whether the user was a paying subscriber when he rated the movie with data format being integer and value descriptions being 1 = the user was a paying subscriber when he rated the movie \n0 = the user was not a paying subscriber when he rated; table \'movies\' contains the following columns: column \'movie_id\' contains ID related to the movie on Mubi with data format being integer and value descriptions being nan; column \'movie_title\' contains Name of the movie with data format being text and value descriptions being nan; column \'movie_release_year\' contains Release year of the movie with data format being integer and value descriptions being nan; column \'movie_url\' contains URL to the movie page on Mubi with data format being text and value descriptions being nan; column \'movie_title_language\' contains By default, the title is in English. with data format being text and value descriptions being Only contains one value which is \'en\'; column \'movie_popularity\' contains Number of Mubi users who love this movie with data format being integer and value descriptions being nan; column \'movie_image_url\' contains Image URL to the movie on Mubi with data format being text and value descriptions being nan; column \'director_id\' contains ID related to the movie director on Mubi with data format being text and value descriptions being nan; column \'director_name\' contains Full Name of the movie director with data format being text and value descriptions being nan; column \'director_url \' contains URL to the movie director page on Mubi with data format being text and value descriptions being nan; '''
        },
        {
            "role": "assistant",
            "content": "SELECT movie_title FROM movies WHERE movie_release_year = 1945 ORDER BY movie_popularity DESC LIMIT 1",
        },
        {
            "role": "user",
            "content": '''On which day was the most verbose complaint received? Specifically, day received refers to \"Date received\"; most verbose complaint refers to MAX(ser_time); table 'reviews' contains the following columns: column 'Date' contains nan with data format being date and value descriptions being nan; column 'Stars' contains nan with data format being integer and value descriptions being nan; column 'Reviews' contains nan with data format being text and value descriptions being nan; column 'Product' contains nan with data format being text and value descriptions being nan; column 'district_id' contains nan with data format being integer and value descriptions being nan; table 'client' contains the following columns: column 'client_id' contains unique id client number with data format being text and value descriptions being nan; column 'sex' contains sex of client with data format being text and value descriptions being nan; column 'day' contains day of the birthday with data format being integer and value descriptions being nan; column 'month' contains month of the birthday with data format being integer and value descriptions being nan; column 'year' contains year when is born with data format being integer and value descriptions being nan; column 'age' contains age  with data format being integer and value descriptions being teenager: 13-19\nadult: 19-65\nelder: > 65; column 'social' contains social number with data format being text and value descriptions being ssn: us id number for each person; column 'first' contains first name with data format being text and value descriptions being nan; column 'middle' contains middle name with data format being text and value descriptions being nan; column 'last' contains last name with data format being text and value descriptions being nan; column 'phone' contains phone number with data format being text and value descriptions being nan; column 'email' contains email with data format being text and value descriptions being commonsense evidence:\ngoogle email / account: @gamil.com\nmicrosoft email / account: xxx@outlook.com; column 'address_1' contains address 1 with data format being text and value descriptions being nan; column 'address_2' contains address 2 with data format being text and value descriptions being entire address = (address_1, address_2); column 'city' contains city  with data format being text and value descriptions being nan; column 'state' contains state code with data format being text and value descriptions being nan; column 'zipcode' contains zipcode with data format being integer and value descriptions being nan; column 'district_id' contains district id number with data format being integer and value descriptions being nan; table 'district' contains the following columns: column 'district_id' contains unique id number representing district with data format being integer and value descriptions being nan; column 'city' contains city  with data format being text and value descriptions being nan; column 'state_abbrev' contains state abbreviated code with data format being text and value descriptions being nan; column 'division' contains division with data format being text and value descriptions being nan; table 'state' contains the following columns: column 'StateCode' contains nan with data format being text and value descriptions being nan; column 'State' contains nan with data format being text and value descriptions being nan; column 'Region' contains nan with data format being text and value descriptions being nan; table 'callcenterlogs' contains the following columns: column 'Date received' contains complaint date with data format being date and value descriptions being nan; column 'Complaint ID' contains unique id number representing each complaint with data format being text and value descriptions being nan; column 'rand client' contains client id with data format being text and value descriptions being nan; column 'phonefinal' contains final phone number with data format being text and value descriptions being nan; column 'vru+line' contains voice response unit line with data format being text and value descriptions being nan; column 'call_id' contains id number identifying the call with data format being integer and value descriptions being nan; column 'priority' contains priority of the complaint with data format being integer and value descriptions being 0, 1, 2, \nnull: not available,\nhigher: -> higher priority,\n-> more serious/urgent complaint; column 'type' contains type of complaint with data format being text and value descriptions being nan; column 'outcome' contains the outcome of processing of complaints with data format being text and value descriptions being nan; column 'server' contains server with data format being text and value descriptions being nan; column 'ser_start' contains server start time with data format being text and value descriptions being HH:MM:SS; column 'ser_exit' contains server exit time with data format being text and value descriptions being nan; column 'ser_time' contains server time with data format being text and value descriptions being commonsense evidence:\nlonger server time referring to more verbose/longer complaint; table 'events' contains the following columns: column 'Date received' contains Date received with data format being date and value descriptions being nan; column 'Product' contains complaining about which product  with data format being text and value descriptions being nan; column 'Sub-product' contains sub product if exists with data format being text and value descriptions being commonsense evidence:\ndetailed product; column 'Issue' contains problems leading to this complaints with data format being text and value descriptions being nan; column 'Sub-issue' contains sub problems leading to this complaints if exists with data format being text and value descriptions being commonsense evidence:\nmore detailed issue; column 'Consumer complaint narrative' contains Consumer complaint narrative with data format being text and value descriptions being nan; column 'Tags' contains tags of client with data format being text and value descriptions being nan; column 'Consumer consent provided?' contains whether the tags labeled under permission of the clients with data format being text and value descriptions being commonsense evidence:\n\x95 null, 'N/A' or empty value: indicating that the company didn't get the permission of consent.\n\x95 if the value is not empty: customers provide the consent for this tag.; column 'Submitted via' contains Submitted via with data format being text and value descriptions being nan; column 'Date sent to company' contains Date sent to company with data format being text and value descriptions being commonsense evidence:\ndelay of the complaints = 'Date sent to company'; column 'Company response to consumer' contains Company response to consumer with data format being text and value descriptions being nan; column 'Timely response?' contains whether the response of the company is timely with data format being text and value descriptions being nan; column 'Consumer disputed?' contains whether the consumer dispute about the response from the company. with data format being text and value descriptions being nan; column 'Complaint ID' contains id number indicating which complaint with data format being text and value descriptions being nan; column 'Client_ID' contains id number indicating which client with data format being text and value descriptions being nan;  '''
        },
        {
            "role": "assistant",
            "content": "SELECT `Date received` FROM callcenterlogs WHERE ser_time = ( SELECT MAX(ser_time) FROM callcenterlogs )",
        },
        {
            "role": "user",
            "content": user_query  # Use the user's query
        }
    ]

    if gpt4:
        response = client.chat.completions.create(
            model="gpt-4-0613",
            messages=messages
        )
        if verbose:
            # num_token_msg = num_tokens_from_messages(messages, "gpt-4-0613")
            # print("Number of tokens of messages for 'query_pd': ", num_token_msg)
            print("VERBOSE:"+"Number of prompt tokens for 'query_gen': ", response.usage.prompt_tokens)
            print("VERBOSE:"+"Number of answer tokens for 'query_gen': ", response.usage.completion_tokens)
            print("VERBOSE:"+"Number of total tokens for 'query_gen': ", response.usage.total_tokens)
            current_pize = 0.000005 * response.usage.prompt_tokens + 0.000015 * response.usage.completion_tokens
            print("VERBOSE:"+f"Cost for 'query_gen': ${current_pize}")
            autopipeline.cost += current_pize
            print("VERBOSE:"+f"Accumulated cost: ${autopipeline.cost}")
    else:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo-0125",
            messages=messages
        )
        if verbose:
            # num_token_msg = num_tokens_from_messages(messages, "gpt-3.5-turbo-0125")
            # print("Number of tokens of messages for 'query_pd': ", num_token_msg)
            print("VERBOSE:"+"Number of prompt tokens for 'query_gen': ", response.usage.prompt_tokens)
            print("VERBOSE:"+"Number of answer tokens for 'query_gen': ", response.usage.completion_tokens)
            print("VERBOSE:"+"Number of total tokens for 'query_gen': ", response.usage.total_tokens)
            current_pize = 0.0000005 * response.usage.prompt_tokens + 0.0000015 * response.usage.completion_tokens
            print("VERBOSE:"+f"Cost for 'query_gen': ${current_pize}")
            autopipeline.cost += current_pize
            print("VERBOSE:"+f"Accumulated cost: ${autopipeline.cost}")
    status.append('code generated')

    if verbose:  # for demo purposes
        content = response.choices[0].message.content
        lines = content.split('\n')
        prefixed_content = '\n'.join('CODE:' + line for line in lines if line.strip())
        print(prefixed_content)
    return response.choices[0].message.content, status