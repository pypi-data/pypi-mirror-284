# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.datetime_utils import serialize_datetime
from ..core.pydantic_utilities import deep_union_pydantic_dicts, pydantic_v1
from ..core.unchecked_base_model import UncheckedBaseModel
from .model_endpoints import ModelEndpoints
from .model_providers import ModelProviders
from .prompt_kernel_request_stop import PromptKernelRequestStop
from .prompt_kernel_request_template import PromptKernelRequestTemplate
from .response_format import ResponseFormat
from .tool_function import ToolFunction


class PromptKernelRequest(UncheckedBaseModel):
    model: str = pydantic_v1.Field()
    """
    The model instance used, e.g. `gpt-4`. See [supported models](https://humanloop.com/docs/supported-models)
    """

    endpoint: typing.Optional[ModelEndpoints] = pydantic_v1.Field(default=None)
    """
    The provider model endpoint used.
    """

    template: typing.Optional[PromptKernelRequestTemplate] = pydantic_v1.Field(default=None)
    """
    For chat endpoint, provide a Chat template. For completion endpoint, provide a Prompt template. Input variables within the template should be specified with double curly bracket syntax: {{INPUT_NAME}}.
    """

    provider: typing.Optional[ModelProviders] = pydantic_v1.Field(default=None)
    """
    The company providing the underlying model service.
    """

    max_tokens: typing.Optional[int] = pydantic_v1.Field(default=None)
    """
    The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
    """

    temperature: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    What sampling temperature to use when making a generation. Higher values means the model will be more creative.
    """

    top_p: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
    """

    stop: typing.Optional[PromptKernelRequestStop] = pydantic_v1.Field(default=None)
    """
    The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
    """

    presence_penalty: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
    """

    frequency_penalty: typing.Optional[float] = pydantic_v1.Field(default=None)
    """
    Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.
    """

    other: typing.Optional[typing.Dict[str, typing.Any]] = pydantic_v1.Field(default=None)
    """
    Other parameter values to be passed to the provider call.
    """

    seed: typing.Optional[int] = pydantic_v1.Field(default=None)
    """
    If specified, model will make a best effort to sample deterministically, but it is not guaranteed.
    """

    response_format: typing.Optional[ResponseFormat] = pydantic_v1.Field(default=None)
    """
    The format of the response. Only `{"type": "json_object"}` is currently supported for chat.
    """

    tools: typing.Optional[typing.List[ToolFunction]] = pydantic_v1.Field(default=None)
    """
    The tool specification that the model can choose to call if Tool calling is supported.
    """

    linked_tools: typing.Optional[typing.List[str]] = pydantic_v1.Field(default=None)
    """
    The IDs of the Tools in your organization that the model can choose to call if Tool calling is supported. The default deployed version of that tool is called.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic_v1.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
