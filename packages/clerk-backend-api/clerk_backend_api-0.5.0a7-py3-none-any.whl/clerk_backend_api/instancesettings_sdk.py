"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from .basesdk import BaseSDK
from clerk_backend_api import models
from clerk_backend_api._hooks import HookContext
from clerk_backend_api.types import Nullable, UNSET
import clerk_backend_api.utils as utils
from typing import List, Optional

class InstanceSettingsSDK(BaseSDK):
    
    
    def update(
        self, *,
        test_mode: Optional[Nullable[bool]] = None,
        hibp: Optional[Nullable[bool]] = None,
        enhanced_email_deliverability: Optional[Nullable[bool]] = None,
        support_email: Optional[Nullable[str]] = None,
        clerk_js_version: Optional[Nullable[str]] = None,
        development_origin: Optional[Nullable[str]] = None,
        allowed_origins: Optional[List[str]] = None,
        cookieless_dev: Optional[bool] = None,
        url_based_session_syncing: Optional[bool] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ):
        r"""Update instance settings

        Updates the settings of an instance

        :param test_mode: Toggles test mode for this instance, allowing the use of test email addresses and phone numbers. Defaults to true for development instances.
        :param hibp: Whether the instance should be using the HIBP service to check passwords for breaches
        :param enhanced_email_deliverability: The \"enhanced_email_deliverability\" feature will send emails from \"verifications@clerk.dev\" instead of your domain. This can be helpful if you do not have a high domain reputation.
        :param support_email: 
        :param clerk_js_version: 
        :param development_origin: 
        :param allowed_origins: For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value. For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.
        :param cookieless_dev: Whether the instance should operate in cookieless development mode (i.e. without third-party cookies). Deprecated: Please use `url_based_session_syncing` instead.
        :param url_based_session_syncing: Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRequestBody(
            test_mode=test_mode,
            hibp=hibp,
            enhanced_email_deliverability=enhanced_email_deliverability,
            support_email=support_email,
            clerk_js_version=clerk_js_version,
            development_origin=development_origin,
            allowed_origins=allowed_origins,
            cookieless_dev=cookieless_dev,
            url_based_session_syncing=url_based_session_syncing,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstance", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
    
    async def update_async(
        self, *,
        test_mode: Optional[Nullable[bool]] = None,
        hibp: Optional[Nullable[bool]] = None,
        enhanced_email_deliverability: Optional[Nullable[bool]] = None,
        support_email: Optional[Nullable[str]] = None,
        clerk_js_version: Optional[Nullable[str]] = None,
        development_origin: Optional[Nullable[str]] = None,
        allowed_origins: Optional[List[str]] = None,
        cookieless_dev: Optional[bool] = None,
        url_based_session_syncing: Optional[bool] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ):
        r"""Update instance settings

        Updates the settings of an instance

        :param test_mode: Toggles test mode for this instance, allowing the use of test email addresses and phone numbers. Defaults to true for development instances.
        :param hibp: Whether the instance should be using the HIBP service to check passwords for breaches
        :param enhanced_email_deliverability: The \"enhanced_email_deliverability\" feature will send emails from \"verifications@clerk.dev\" instead of your domain. This can be helpful if you do not have a high domain reputation.
        :param support_email: 
        :param clerk_js_version: 
        :param development_origin: 
        :param allowed_origins: For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value. For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.
        :param cookieless_dev: Whether the instance should operate in cookieless development mode (i.e. without third-party cookies). Deprecated: Please use `url_based_session_syncing` instead.
        :param url_based_session_syncing: Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRequestBody(
            test_mode=test_mode,
            hibp=hibp,
            enhanced_email_deliverability=enhanced_email_deliverability,
            support_email=support_email,
            clerk_js_version=clerk_js_version,
            development_origin=development_origin,
            allowed_origins=allowed_origins,
            cookieless_dev=cookieless_dev,
            url_based_session_syncing=url_based_session_syncing,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstance", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "422", "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
    
    def update_restrictions(
        self, *,
        allowlist: Optional[Nullable[bool]] = None,
        blocklist: Optional[Nullable[bool]] = None,
        block_email_subaddresses: Optional[Nullable[bool]] = None,
        block_disposable_email_domains: Optional[Nullable[bool]] = None,
        ignore_dots_for_gmail_addresses: Optional[Nullable[bool]] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ) -> models.InstanceRestrictions:
        r"""Update instance restrictions

        Updates the restriction settings of an instance

        :param allowlist: 
        :param blocklist: 
        :param block_email_subaddresses: 
        :param block_disposable_email_domains: 
        :param ignore_dots_for_gmail_addresses: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRestrictionsRequestBody(
            allowlist=allowlist,
            blocklist=blocklist,
            block_email_subaddresses=block_email_subaddresses,
            block_disposable_email_domains=block_disposable_email_domains,
            ignore_dots_for_gmail_addresses=ignore_dots_for_gmail_addresses,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/restrictions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRestrictionsRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstanceRestrictions", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Optional[models.InstanceRestrictions])
        if utils.match_response(http_res, ["402","422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
    
    async def update_restrictions_async(
        self, *,
        allowlist: Optional[Nullable[bool]] = None,
        blocklist: Optional[Nullable[bool]] = None,
        block_email_subaddresses: Optional[Nullable[bool]] = None,
        block_disposable_email_domains: Optional[Nullable[bool]] = None,
        ignore_dots_for_gmail_addresses: Optional[Nullable[bool]] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ) -> models.InstanceRestrictions:
        r"""Update instance restrictions

        Updates the restriction settings of an instance

        :param allowlist: 
        :param blocklist: 
        :param block_email_subaddresses: 
        :param block_disposable_email_domains: 
        :param ignore_dots_for_gmail_addresses: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceRestrictionsRequestBody(
            allowlist=allowlist,
            blocklist=blocklist,
            block_email_subaddresses=block_email_subaddresses,
            block_disposable_email_domains=block_disposable_email_domains,
            ignore_dots_for_gmail_addresses=ignore_dots_for_gmail_addresses,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/restrictions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceRestrictionsRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstanceRestrictions", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Optional[models.InstanceRestrictions])
        if utils.match_response(http_res, ["402","422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
    
    def update_organization_settings(
        self, *,
        enabled: Optional[Nullable[bool]] = None,
        max_allowed_memberships: Optional[Nullable[int]] = None,
        admin_delete_enabled: Optional[Nullable[bool]] = None,
        domains_enabled: Optional[Nullable[bool]] = None,
        domains_enrollment_modes: Optional[List[str]] = None,
        creator_role_id: Optional[str] = None,
        domains_default_role_id: Optional[str] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ) -> models.OrganizationSettings:
        r"""Update instance organization settings

        Updates the organization settings of the instance

        :param enabled: 
        :param max_allowed_memberships: 
        :param admin_delete_enabled: 
        :param domains_enabled: 
        :param domains_enrollment_modes: Specify which enrollment modes to enable for your Organization Domains. Supported modes are 'automatic_invitation' & 'automatic_suggestion'.
        :param creator_role_id: Specify what the default organization role is for an organization creator.
        :param domains_default_role_id: Specify what the default organization role is for the organization domains.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceOrganizationSettingsRequestBody(
            enabled=enabled,
            max_allowed_memberships=max_allowed_memberships,
            admin_delete_enabled=admin_delete_enabled,
            domains_enabled=domains_enabled,
            domains_enrollment_modes=domains_enrollment_modes,
            creator_role_id=creator_role_id,
            domains_default_role_id=domains_default_role_id,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/organization_settings",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceOrganizationSettingsRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="UpdateInstanceOrganizationSettings", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","404","422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Optional[models.OrganizationSettings])
        if utils.match_response(http_res, ["402","404","422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
    
    async def update_organization_settings_async(
        self, *,
        enabled: Optional[Nullable[bool]] = None,
        max_allowed_memberships: Optional[Nullable[int]] = None,
        admin_delete_enabled: Optional[Nullable[bool]] = None,
        domains_enabled: Optional[Nullable[bool]] = None,
        domains_enrollment_modes: Optional[List[str]] = None,
        creator_role_id: Optional[str] = None,
        domains_default_role_id: Optional[str] = None,
        retries: Optional[Nullable[utils.RetryConfig]] = UNSET,
        server_url: Optional[str] = None,
        timeout_config: Optional[int] = None,
    ) -> models.OrganizationSettings:
        r"""Update instance organization settings

        Updates the organization settings of the instance

        :param enabled: 
        :param max_allowed_memberships: 
        :param admin_delete_enabled: 
        :param domains_enabled: 
        :param domains_enrollment_modes: Specify which enrollment modes to enable for your Organization Domains. Supported modes are 'automatic_invitation' & 'automatic_suggestion'.
        :param creator_role_id: Specify what the default organization role is for an organization creator.
        :param domains_default_role_id: Specify what the default organization role is for the organization domains.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_config: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_config is None:
            timeout_config = self.sdk_configuration.timeout_config
        
        if server_url is not None:
            base_url = server_url
        
        request = models.UpdateInstanceOrganizationSettingsRequestBody(
            enabled=enabled,
            max_allowed_memberships=max_allowed_memberships,
            admin_delete_enabled=admin_delete_enabled,
            domains_enabled=domains_enabled,
            domains_enrollment_modes=domains_enrollment_modes,
            creator_role_id=creator_role_id,
            domains_default_role_id=domains_default_role_id,
        )
        
        req = self.build_request(
            method="PATCH",
            path="/instance/organization_settings",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, True, "json", Optional[models.UpdateInstanceOrganizationSettingsRequestBody]),
            timeout_config=timeout_config,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="UpdateInstanceOrganizationSettings", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["402","404","422","4XX","5XX"],
            retry_config=retry_config
        )
        
        
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, Optional[models.OrganizationSettings])
        if utils.match_response(http_res, ["402","404","422"], "application/json"):
            data = utils.unmarshal_json(http_res.text, models.ClerkErrorsData)
            raise models.ClerkErrors(data=data)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise models.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise models.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)
    
