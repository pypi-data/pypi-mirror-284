import base64
import json
import logging
import os
from datetime import datetime, timedelta
from http import HTTPStatus
from typing import Optional, List

import backoff
import pandas as pd
import requests
import toml
from cachetools import TTLCache

logging.getLogger("backoff").setLevel(logging.ERROR)


class Client:
    def __init__(self, org_id, credentials_file, base_url=None, proxies=None):
        self.org_id = org_id
        self.credentials_file = credentials_file
        self._cache = TTLCache(maxsize=1, ttl=15 * 60)
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        config_file_path = os.path.join(project_root, "config/api_config.toml")
        self.config = toml.load(config_file_path)

        if base_url is not None:
            self.base_url = base_url
        else:
            # need to decode base64 server address to str
            base64_encode = self.config["api"]["base_url"]
            base_url_decode = base64.decodebytes(bytes(base64_encode, "ascii")).decode()
            self.base_url = base_url_decode

        self.proxies = proxies

        # Configure logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def set_token(self, token) -> str:
        self._cache["api_token"] = token
        return token

    def get_token(self) -> str:
        """
        Checks client cache for a valid token and retrieves one via credential if necessary

        Returns:
             A valid Access token
        """
        cached_token = self._cache.get("api_token")
        if cached_token:
            self.logger.debug("Token fetched from cache.")
            return cached_token
        else:
            self.logger.debug("Fetch token.")
            if "{" not in self.credentials_file:
                with open(self.credentials_file) as f:
                    sa = json.load(f)
            else:
                sa = json.loads(self.credentials_file)

            token_request = dict(
                grant_type="password",
                username=sa["account_id"],
                password=sa["secret_key"],
                scope="openid",
                client_id=sa["client_id"],
                response_type="token",
            )
            token_response = requests.post(sa["token_uri"], data=token_request, proxies=self.proxies)
            access_token = token_response.json()["access_token"]
            self.logger.debug("Save token to cache.")
            self._cache["api_token"] = access_token
            return access_token

    def _required_headers(self):
        return {
            "Authorization": f"Bearer {self.get_token()}",
            "LR-Org-ID": self.org_id,
            "Content-Type": "application/json",
        }

    @backoff.on_exception(
        backoff.expo,
        requests.exceptions.RequestException,
        max_tries=5,
    )
    def process_request(self, method, endpoint, data=None, params=None):
        """
        Direct call to clean room API
        """
        # Set header
        headers = self._required_headers()
        full_endpoint = f"{self.base_url}{self.config['api']['version']}{endpoint}"

        self.logger.debug(f"Request: {method} {full_endpoint}")
        response = requests.request(
            method, full_endpoint, json=data, headers=headers, params=params, proxies=self.proxies
        )

        if response.status_code not in [
            HTTPStatus.ACCEPTED,
            HTTPStatus.OK,
            HTTPStatus.CREATED,
            HTTPStatus.MULTI_STATUS,
            HTTPStatus.NOT_FOUND,
        ]:
            self.logger.error(
                f"Unexpected response: {response.status_code}, {response.text}"
            )
            raise Exception(
                f"Unexpected response: {response.status_code}, {response.text}"
            )

        if response.headers.get('content-type') == 'application/json':
            return response.json()

        return response.status_code

    def run_query(self, query: str) -> str:
        """Send a request to run a query.

        Params:
            * query: An sql statement

        Returns:
            On Success: A query id str

            On Error: An exception will be thrown containing the HTTP Status Code and message
        """

        endpoint = self.config["endpoints"]["sql_resource"]

        # Get the query details immediately
        request_timeout_seconds = 0

        sql_request = dict(statement=query, timeoutSeconds=request_timeout_seconds)
        response = self.process_request("POST", endpoint, sql_request)

        return response["id"]

    def get_sql_metadata(self, query_id: str) -> json:
        """
        Get a query's metadata by the query id

        Params:
            * query_id: query id generated by running a query

        Returns:
            On Success: JSON formatted response representing the query's metadata including its status

            On Error: An exception will be thrown containing the HTTP Status Code and message
        """
        endpoint = self.config["endpoints"]["sql_operation"].format(query_id=query_id)
        response_data = self.process_request("GET", endpoint)
        return response_data

    @backoff.on_predicate(
        backoff.expo,
        lambda r: r["status"] not in ["SUCCESS", "ERROR"],
        max_value=20,
        max_time=2700,
    )
    def _get_query_status(self, query_id):
        """
        Get your status of an executed query

        query_id: query id
        :return: query details
        """

        response_data = self.get_sql_metadata(query_id)
        self.logger.info(f"Query {response_data['id']} is still running")
        return response_data

    def get_result(self, query_id: str):
        """Retrieves a query's results as a DataFrame by query id

        Polls for a query result via the query id. Polling is done with a 45min timeout at an exponential rate with
        a max delay of 20s if the query is still in a running state

        Params:
            * query_id: query id

        Returns:
            On Success: DataFrame of results

            On Error: Exception thrown with error details
        """
        response_data = self._get_query_status(query_id)
        if response_data["status"] == "SUCCESS" and "dataParts" in response_data["result"]:
            data_parts = response_data["result"]["dataParts"]
            return self.get_data_by_data_parts(data_parts)
        elif response_data["status"] == "ERROR":
            error_msg = f"Query {response_data['id']} Failed. Reason: {response_data['result']['message']}"
            self.logger.info(error_msg)
            return None

    def get_data_by_data_parts(self, data_parts: List[str]):
        """
        Gets a dataframe from a list of data part urls

        Params:
            * data_parts:

        Returns:
             A pandas dataframe
        """
        dfs = []
        for data_part_url in data_parts:
            # Use Pandas to read each Parquet data part and append it to the list
            df = self._get_results(data_part_url)
            dfs.append(df)
        # Concatenate all DataFrames into a single DataFrame
        concatenated_df = pd.concat(dfs, ignore_index=True)
        return concatenated_df

    def get_sql_result_metadata(self, query_id: str) -> json:
        """
        Gets the metadata for the result of a query via the query's id

        Params:
            * query_id: query id

        Returns:
            On Success: JSON with metadata

            On Error: An exception is thrown with error details
        """
        endpoint = self.config["endpoints"]["sql_result"].format(query_id=query_id)
        response_data = self.process_request("GET", endpoint)
        return response_data

    def _get_results(self, url):
        return pd.read_parquet(url, storage_options=self._required_headers())

    def get_query_list(
            self,
            limit: int = None,
            after: str = None,
            start_time: datetime = None,
            end_time: datetime = None,
            query_org_id: str = None,
            status: str = None,
            sort_by: str = None,
            sort_order: str = None,
    ):
        """
        To list all queries to which you have access. This will list past requests run by yourself, and those run
        by your partners, if they referenced assets owned by your organisation.

        Params:
            * limit: the limit of the result you want.
            * after: If you would like to fetch the next page of the list, you can pass the value of _pagination.after property as an after parameter to the get_query_list function.
            * start_time: queries after this time.
            * end_time: queries before this time.
            * query_org_id: filter the queries to only those run by your org
            * status: accepted values are RUNNING, SUCCESS and ERROR
            * sort_by: createdOn, queryOrgId, status and queryOrgId
            * sort_order: desc or asc

        Returns:
            JSON Object containing a list of query metadata that match

        """
        params = {}
        if limit:
            params["limit"] = limit
        if after:
            params["after"] = after
        if start_time:
            params["startTime"] = start_time.strftime("%Y-%m-%dT%H:%M:%SZ")
        if end_time:
            params["endTime"] = start_time.strftime("%Y-%m-%dT%H:%M:%SZ")
        if query_org_id:
            params["queryOrgId"] = query_org_id
        if status:
            params["status"] = status
        if sort_by:
            params["sortBy"] = sort_by
        if sort_order:
            params["sortOrder"] = sort_order
        endpoint = self.config["endpoints"]["sql_resource"]

        response_data = self.process_request("GET", endpoint, params=params)
        return response_data

    def create_view(self, name: str, sql: str) -> str:
        """
        DEPRECATED
        """
        view_request = {"name": name, "sql": sql}
        endpoint = self.config["endpoints"]["view_resource"]

        response_data = self.process_request("POST", endpoint, data=view_request)
        return response_data["id"]

    def delete_view(self, view_id: str) -> int:
        """
        DEPRECATED
        """
        endpoint = self.config["endpoints"]["view_operation"].format(id=view_id)

        response_data = self.process_request("DELETE", endpoint)
        return response_data

    def get_assets(self):
        """
        Gets all assets for the organization

        Returns:
            list of assets
        """
        (assets, next_page) = self._get_assets_page()
        while next_page:
            (assets_on_page, next_page) = self._get_assets_page(limit=None, after=next_page)
            assets += assets_on_page

        return assets

    def _get_assets_page(self, limit=None, after=None):
        params = {}
        if limit:
            params["limit"] = limit
        if after:
            params["after"] = after
        endpoint = self.config["endpoints"]["asset_resource"]
        response_data = self.process_request("GET", endpoint, params=params)

        assets_on_page = response_data["assets"]
        next_page = None
        if response_data.get("_pagination") is not None:
            next_page = response_data.get("_pagination").get("after")

        return assets_on_page, next_page

    def add_asset_tags(self, asset_id: str, tags: List[str]) -> json:
        """
        Add tags for a given asset

        Params:
            * asset_id:
            * tags:

        """
        asset_tags = {"assetTags": [{"assetID": asset_id, "tags": tags}]}
        endpoint = self.config["endpoints"]["asset_add_tag"]
        response_data = self.process_request("POST", endpoint, data=asset_tags)
        return response_data

    def remove_asset_tags(self, asset_id: str, tags: List[str]) -> json:
        """
        Remove asset tags for a given asset

        Params:
            * asset_id:
            * tags:
        """
        asset_tags = {"assetTags": [{"assetID": asset_id, "tags": tags}]}
        endpoint = self.config["endpoints"]["asset_remove_tag"]
        response_data = self.process_request("POST", endpoint, data=asset_tags)
        return response_data

    def share_udf(
            self,
            name: str,
            asset_ids: List[str],
            partner_id: str,
            query_visibility: bool,
            udf_visibility: bool,
            number_of_days: int = None,
    ) -> str:
        """
        Create a permission that shares a UDF with a partner org

        Params:
            * name:
            * asset_ids:
            * partner_id:
            * query_visibility:
            * udf_visibility:
            * number_of_days:

        Returns:
            id of permission created
        """
        permission_request = {
            "name": name,
            "assetIDs": asset_ids,
            "partnerOrgID": partner_id,
            "startDate": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "collaborationRules": {
                "dataActivityVisibility": {"query": query_visibility},
                "propertiesVisibility": {"createStatement": udf_visibility},
            },
        }

        if number_of_days:
            permission_request["endDate"] = (
                    datetime.utcnow() + timedelta(days=number_of_days)
            ).strftime("%Y-%m-%dT" "%H:%M:%SZ")

        endpoint = self.config["endpoints"]["permission_resource"]
        response_data = self.process_request("POST", endpoint, data=permission_request)
        return response_data["id"]

    def share_table_or_view(
            self,
            name,
            asset_ids,
            partner_id,
            allow_joining_with_partners_data,
            allow_joining_with_data_providers_data,
            allow_joining_with_other_orgs_data,
            allow_joining_with_specific_orgs_data,
            minimum_aggregation_column=None,
            minimum_aggregation_records=None,
            number_of_days=None,
    ):
        """
        Share tables or views (assets) with a partner

        Params:
            * name: Any name you choose for the permission
            * asset_ids:
            * partner_id:
            * allow_joining_with_partners_data:
            * allow_joining_with_data_providers_data:
            * allow_joining_with_other_orgs_data:
            * allow_joining_with_specific_orgs_data:
            * minimum_aggregation_column:
            * minimum_aggregation_records:
            * number_of_days:

        Returns:
            id of permission created
        """
        collaboration_rules = {
            "dataCombinations": {
                "myPartner": allow_joining_with_partners_data,
                "dataProvider": allow_joining_with_data_providers_data,
                "otherOrgs": allow_joining_with_other_orgs_data,
                "orgs": allow_joining_with_specific_orgs_data,
            }
        }

        if minimum_aggregation_column and minimum_aggregation_records:
            collaboration_rules["queryThreshold"] = {
                "aggregationColumn": minimum_aggregation_column,
                "minRecords": minimum_aggregation_records,
            }

        permission_request = {
            "name": name,
            "assetIDs": asset_ids,
            "partnerOrgID": partner_id,
            "startDate": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "collaborationRules": collaboration_rules,
        }

        if number_of_days:
            permission_request["endDate"] = (
                    datetime.utcnow() + timedelta(days=number_of_days)
            ).strftime("%Y-%m-%dT%H:%M:%SZ")

        endpoint = self.config["endpoints"]["permission_resource"]
        response_data = self.process_request("POST", endpoint, data=permission_request)

        return response_data["id"]

    def list_permissions(self,
                         asset_ids: List[str] = None,
                         statuses: List[str] = None,
                         after: str = None):
        """
        Retrieve Permissions that match the provided criteria

        Params:
            * asset_ids:
            * statuses:
            * after:

        Returns:
            A list of permissions
        """
        asset_ids_param = {"assetIDs": ",".join(asset_ids)} if asset_ids else {}
        statuses_param = {"statuses": ",".join(statuses)} if statuses else {}
        after_param = {"after": after} if after else {}

        endpoint = self.config["endpoints"]["permission_resource"]
        response_data = self.process_request(
            "GET",
            endpoint,
            params={
                **{"limit": 500},
                **asset_ids_param,
                **statuses_param,
                **after_param,
            },
        )

        pagination = response_data.get("_pagination")
        new_after = pagination["after"] if "after" in pagination else None
        remaining_permissions = (
            self.list_permissions(asset_ids, statuses, new_after) if new_after else []
        )
        return response_data["permissions"] + remaining_permissions

    def update_permission(self, permission_id: str, end_date: Optional[str]):
        """
        Update the end/expiration date of an existing permission - providing None for end_date will
        remove the expiration date

        Params:
            * permission_id:
            * end_date: in the format "%Y-%m-%dT%H:%M:%SZ"

        Returns:
            Updated permission
        """
        permission_request = {}
        if end_date:
            permission_request["endDate"] = end_date
        endpoint = self.config["endpoints"]["permission_operation"].format(
            id=permission_id
        )
        response_data = self.process_request("PATCH", endpoint, data=permission_request)
        return response_data

    def revoke_permission(self, permission_id: str) -> int:
        """
        Revoke an existing permission

        Params:
            * permission_id:

        Returns:
            200
        """
        endpoint = self.config["endpoints"]["permission_operation"].format(
            id=permission_id
        )
        response_data = self.process_request("DELETE", endpoint)
        return response_data

    def list_partners(self):
        """
        List all the orgs you are partnered with
        """
        endpoint = self.config["endpoints"]["partner_resource"]
        response_data = self.process_request("GET", endpoint)
        return response_data

    def list_pre_approved_data_combination_partners(self):
        endpoint = self.config["endpoints"][
            "partner_data_combination_approved_resource"
        ]
        response_data = self.process_request("GET", endpoint)
        return response_data
