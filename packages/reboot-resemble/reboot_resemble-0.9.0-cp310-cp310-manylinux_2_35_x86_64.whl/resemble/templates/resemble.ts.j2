import {
  codegenInfo as __bufbuildProtobufCodegenInfo,
  PartialMessage as __bufbuildProtobufPartialMessage,
{% if google_protobuf_used_messages is defined and google_protobuf_used_messages|length > 0%}
  {{ google_protobuf_used_messages|join(', \n	') }}
{% endif %}
} from "@bufbuild/protobuf";
{% if proto.messages_and_enums | length > 0 %}
import {
{% for message in proto.messages_and_enums | unique | list %}
  {% if message not in proto.states %}
  {{ message }},
  {% endif %}
{% endfor %}
} from "./{{ pb_name }}.js";
{% endif %}

{# Since we are creating a new class named {{ state }}, we can't import the same
name from the {{ pb_name }}.js, so we have to alias that to use inside of that
file, to the enduser we export that type as {{ state }}.State #}
{% if proto.states|length > 0 %}
{% for state in proto.states %}
import {
  {{ state }} as {{ state }}Proto,
} from "./{{ pb_name }}.js";
{% endfor %}
{% endif %}

import {
  Context,
  Workflow,
  ReaderContext,
  WriterContext,
  TransactionContext,
  clearFields as __reboot_dev_resemble_clearFields,
} from "@reboot-dev/resemble";
import { fileURLToPath } from "node:url";
import * as path from "node:path";

import * as resembleNative from "@reboot-dev/resemble/resemble_native.cjs";

{% if imports|length > 0 %}
// Include all transitive imports.
{% for import_path, unique_name in imports.items() %}
import * as {{ unique_name }} from "{{ import_path }}";
{% endfor %}
{% endif %}

// To support writers seeing partial updates of transactions,
// and transactions seeing updates from writers, we need to store
// a reference to the latest state in an ongoing transaction.
//
// Moreover, we need to update that _reference_ after each writer
// executes within a transaction. We do that in the generated
// code, see below.
const ongoingTransactionStates: { [id: string] : any; } = {};

{# Start generated Interface code #}
{% for service in services %}

export abstract class {{ service.options.proto.state_name }}Interface {
  static __rsmModule__ = "{{ rsm_name }}";
  static __servicerNodeAdaptor__ = "{{ service.options.proto.state_name }}ServicerNodeAdaptor";

  protected lookup() {
    return new {{ service.options.proto.state_name }}.WeakReference(null);
  }

  {% for method in service.methods %}
  abstract {{ method.proto.name }}(
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext,
    {% elif method.options.proto.kind == 'writer' %}
    context: WriterContext,
    {% elif method.options.proto.kind == 'transaction' %}
    context: TransactionContext,
    {% endif %}
    state: {{ service.options.proto.state_name }}Proto,
    request: {{ method.input_type }},
  ): Promise<
  {{ method.output_type }} | __bufbuildProtobufPartialMessage<{{ method.output_type }}>
  >;
  {% endfor %}

  {% for method in service.methods %}
  async _{{ method.proto.name }}(
    {% if method.options.proto.kind == 'reader' %}
    context: ReaderContext,
    {% elif method.options.proto.kind == 'writer' %}
    context: WriterContext,
    {% elif method.options.proto.kind == 'transaction' %}
    context: TransactionContext,
    {% endif %}
    jsonState: string,
    jsonRequest: string
  ): Promise<string> {
    try {
      let state = new {{ service.options.proto.state_name }}Proto(
        JSON.parse(jsonState)
      );
      {% if method.options.proto.kind == 'writer' %}
      if (context.actorId in ongoingTransactionStates) {
        state = ongoingTransactionStates[context.actorId].clone();
      }
      {% elif method.options.proto.kind == 'transaction' %}
      // TODO: assert that there are no ongoing transactions for this state.
      ongoingTransactionStates[context.actorId] = state;
      {% endif %}
      const response = await this.{{ method.proto.name }}(
        context,
        state,
        new {{ method.input_type }}(JSON.parse(jsonRequest))
      );
      {% if method.options.proto.kind == 'writer' %}
      // TODO: it's premature to overwrite the state now given that the
      // writer might still "fail" and an error will get propagated back
      // to the ongoing transaction which will still see the effects of
      // this writer. What we should be doing instead is creating a
      // callback API that we invoke only after a writer completes
      // that lets us update the state _reference_ then.
      if (context.actorId in ongoingTransactionStates) {
        // Unfortunately, protobuf-es does not have `CopyFrom` like Python
        // or C++ protobuf. Instead, protobuf-es has `fromJson` but it
        // performs a merge. Thus, we have to first clear all of the fields
        // in the message before calling `fromJson`.
         __reboot_dev_resemble_clearFields(
           ongoingTransactionStates[context.actorId],
           __bufbuildProtobufCodegenInfo.scalarDefaultValue
         );
        ongoingTransactionStates[context.actorId].fromJson(state.toJson());
      }
      {% elif method.options.proto.kind == 'transaction' %}
      delete ongoingTransactionStates[context.actorId];
      {% endif %}
      return JSON.stringify(
        {% if method.options.proto.kind in ['writer', 'transaction'] %}
        new {{ service.options.proto.state_name }}.{{ method.proto.name }}.Effects({
          state, response
        })
        {% else %}
        response
        {% endif %}
      );
    } catch (e) {
      let error;
      if (e instanceof Error) {
        error = e;
      } else {
        // TODO: is there a better way to get the stringification
        // of an object?
        error = new Error(`${e}`);
      }
      console.log(
        `Unhandled (in '{{ proto.package_name }}.{{ service.options.proto.state_name }}.{{ method.proto.name }}'); propagating as 'Unknown'\n${error.stack}`
      );
      throw (error);
    }
  }

  {% endfor %}
}
{% endfor %}
{# End generated Interface code #}
{# Start generated Service code #}
{% for service in services %}

export class {{ service.options.proto.state_name }} {

  static Interface = {{ service.options.proto.state_name }}Interface;
  {# We have to define State alias there, to make users be able to create
  variables with {{ service.options.proto.state_name }}.State #}
  static State = {{ service.options.proto.state_name }}Proto;

  {% for method in service.methods if method.options.proto.kind in ['writer', 'transaction'] %}

  static {{ method.proto.name }} = class {
    static Effects = class {
      state: {{ service.options.proto.state_name }}Proto;
      response: {{ method.output_type }};

      constructor(effects: {
        state: __bufbuildProtobufPartialMessage<{{ service.options.proto.state_name }}Proto>;
        response: __bufbuildProtobufPartialMessage<{{ method.output_type }}>;
      }) {
        this.state = effects.state instanceof {{
        service.options.proto.state_name }}Proto ? effects.state : new {{ service.options.proto.state_name }}Proto(effects.state);
        this.response = effects.response instanceof {{
        method.output_type }} ? effects.response : new {{ method.output_type }}(effects.response);
      }
    };
  };
  {% endfor %}

  static WeakReference = class {
    #external;
    #id: string | undefined;

    // TODO: using `null` to do "lazy" construction
    // once we have the id from a context.
    constructor(id: string | null) {
      if (typeof id === "string") {
        this.#id = id;
      } else if (id !== null) {
        throw new Error("Expecting 'id'");
      }
    }

    {% for method in service.methods %}
    async {{ method.proto.name }}(
      {% if method.options.proto.kind == 'reader' %}
      contextOrWorkflow: ReaderContext | WriterContext | TransactionContext | Workflow,
      {% elif method.options.proto.kind in ['writer', 'transaction'] %}
      contextOrWorkflow: WriterContext | TransactionContext | Workflow,
      {% endif %}
      partialRequest: __bufbuildProtobufPartialMessage<{{ method.input_type }}>
    ): Promise<{{ method.output_type }}> {
      if (this.#external === undefined) {
        if (this.#id === undefined) {
          if (!(contextOrWorkflow instanceof Context)) {
            throw new Error(
              "Lazy construction of '{{ service.options.proto.state_name }}.WeakReference' " +
              "only valid when using a context, e.g., 'ReaderContext', 'WriterContext', etc"
            );
          }
          this.#id = contextOrWorkflow.actorId;
        }
        this.#external = resembleNative.Service_constructor({
          rsmModule: "{{ rsm_name }}",
          nodeAdaptor: "{{ service.options.proto.state_name }}WeakReferenceNodeAdaptor",
          id: this.#id,
        });
      }

      const request = partialRequest instanceof {{ method.input_type }} ?
        partialRequest : new {{ method.input_type }}(partialRequest);

      return new {{ method.output_type }}(
        JSON.parse(
          await resembleNative.Service_call({
            external: this.#external,
            kind: "{{ method.options.proto.kind }}",
            method: "{{ method.proto.name }}",
            {% if method.python_request_message_module is not none %}
            requestModule: "{{ method.python_request_message_module }}",
            {% else %}
            requestModule: "{{ pb2_name }}",
            {% endif %}
            requestType: "{{ method.python_input_type }}",
            contextOrWorkflow: contextOrWorkflow.external(),
            jsonRequest: JSON.stringify(request),
          })
        )
      );
    }

    {% endfor %}
  }

  public static lookup(id: string) {
    return new {{ service.options.proto.state_name }}.WeakReference(id);
  }
}

{% for method in service.methods if method.options.proto.kind in ['writer', 'transaction'] %}
export namespace {{ service.options.proto.state_name }}.{{ method.proto.name }} {
  export type Effects = typeof {{ service.options.proto.state_name }}.{{ method.proto.name }}.Effects.prototype;
}
{% endfor %}

export namespace {{ service.options.proto.state_name }} {
  {# That State alias is responsible for allowing users use
  {{ service.options.proto.state_name }}.State as a type #}
  export type State = {{ service.options.proto.state_name }}Proto;
}
{% endfor %}
{# End generated Service code #}

resembleNative.importPy("{{ pb2_name }}", "{{ base64_gzip_pb2_py }}");
resembleNative.importPy("{{ pb2_grpc_name }}", "{{ base64_gzip_pb2_grpc_py }}");
resembleNative.importPy("{{ rsm_name }}", "{{ base64_gzip_rsm_py }}");
