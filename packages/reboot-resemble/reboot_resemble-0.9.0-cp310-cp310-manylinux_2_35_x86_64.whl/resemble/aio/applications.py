import aiofiles.os
import asyncio
import colorama
import os
import sys
import traceback
import uuid
from resemble.aio.auth.token_verifiers import TokenVerifier
from resemble.aio.servers import (
    InitializerError,
    InstantiateError,
    Server,
    run_application_initializer,
)
from resemble.aio.servicers import Serviceable, Servicer
from resemble.aio.tests import Resemble
from resemble.aio.workflows import Workflow
from resemble.cli import terminal
from resemble.consensus.service_descriptor_validator import (
    ProtoValidationError,
)
from resemble.consensus.sidecar import SidecarServerFailed
from resemble.controller.exceptions import InputError
from resemble.controller.settings import USER_CONTAINER_GRPC_PORT
from resemble.run_environments import (
    InvalidRunEnvironment,
    RunEnvironment,
    _detect_run_environment,
)
from resemble.settings import (
    DEFAULT_SECURE_PORT,
    ENVVAR_RSM_DIRECTORY,
    ENVVAR_RSM_LOCAL_ENVOY,
    ENVVAR_RSM_LOCAL_ENVOY_PORT,
    ENVVAR_RSM_NAME,
)
from respect.logging import get_logger
from typing import Awaitable, Callable, Optional

logger = get_logger(__name__)


def _handle_unknown_exception(
    exception: Exception,
    stack_trace: Optional[str] = None,
    with_contact_info: bool = True,
) -> None:
    """Pretty print stack trace and error message for an unknown exception. This
    includes informing the user how to best get in touch with us.
    """
    if stack_trace is None:
        stack_trace = ''.join(traceback.format_exception(exception))

    # Emulate `traceback.print_exc()` by printing the
    # error to `sys.stderr`.
    print(stack_trace, file=sys.stderr)

    terminal.error(f'Caught unexpected `{type(exception).__name__}`.\n'
                   '\n')
    if not with_contact_info:
        return

    terminal.warn(
        'Please report this error, including the stack trace above, \n'
        'to the kind folks at Reboot - they\'ll be happy to help you out!\n'
        'You can get in touch via Discord: https://discord.gg/cRbdcS94Nr\n'
        '\n'
    )


def _maybe_handle_exception(exception: Exception) -> bool:
    """Attempt to handle an arbitrary exception. If the exception is well
    understood, print helpful messages to the user and return `True`. Otherwise,
    return `False`.
    """
    if isinstance(exception, ProtoValidationError):
        terminal.error(
            f'Protobuf validation failed during startup: {exception.reason}.'
        )

        assert exception.parent_exception is not None
        list_of_validation_errors: list[ProtoValidationError
                                       ] = exception.parent_exception.args[0]
        for validation_error in list_of_validation_errors:
            terminal.error(f'  - {validation_error.reason}')
        terminal.error('\n')

        return True

    elif isinstance(exception, SidecarServerFailed):
        if (
            'Failed to instantiate service' in str(exception) and
            '/LOCK:' in str(exception)
        ):
            terminal.error('\n'
                           "Sidecar server failed to start."
                           '\n')
            terminal.warn(
                'Did you start another instance of `rsm dev run` '
                'in another terminal?'
                '\n'
            )

            return True

    return False


def _handle_input_error(input_error: InputError) -> None:
    """Handle an input error by checking if we can make sense of the parent
    exception."""
    error_is_understood = False
    if input_error.parent_exception is not None:
        error_is_understood = _maybe_handle_exception(
            input_error.parent_exception
        )

    with_contact_info = True
    if isinstance(input_error.parent_exception, InitializerError):
        with_contact_info = False

    if isinstance(input_error.parent_exception, InstantiateError):
        with_contact_info = False

    if not error_is_understood:
        _handle_unknown_exception(
            input_error,
            input_error.stack_trace,
            with_contact_info,
        )

    terminal.error('\n'
                   f'{input_error.reason}'
                   '\n')


class Application:
    """Entry point for all resemble applications."""

    def __init__(
        self,
        *,
        servicers: Optional[list[type[Servicer]]] = None,
        # A legacy gRPC servicer type can't be more specific than `type`,
        # because legacy gRPC servicers (as generated by the gRPC `protoc`
        # plugin) do not share any common base class other than `object`.
        legacy_grpc_servicers: Optional[list[type]] = None,
        initialize: Optional[Callable[[Workflow], Awaitable[None]]] = None,
        initialize_bearer_token: Optional[str] = None,
        token_verifier: Optional[TokenVerifier] = None,
    ):
        """
        :param servicers: the types of Resemble-powered servicers that this
                          Application will serve.
        :param legacy_grpc_servicers: the types of legacy gRPC servicers (not
                                      using Resemble libraries) that this
                                      Application will serve.

        :param initialize: will be called after the Application's servicers have
                       started for the first time, so that it can perform
                       initialization logic (e.g., creating some well-known
                       actors, loading some data, etc. It must do so in the
                       context of the given Workflow.

        :param initialize_bearer_token: a Bearer token that will be used to construct
            the `Workflow` passed to `initialize`.

        :param token_verifier: a TokenVerifier that will be used to verify
            authorization bearer tokens passed to the application.

        TODO(benh): update the initialize function to be run in a transaction
        and ensure that the transaction has finished before serving any other
        calls on the servicers.
        """
        self._servicers = servicers
        self._legacy_grpc_servicers = legacy_grpc_servicers
        self._initialize = initialize
        self._token_verifier = token_verifier
        self._initialize_bearer_token = initialize_bearer_token

        self._rsm: Optional[Resemble] = None

        try:
            run_environment = _detect_run_environment()
        except InvalidRunEnvironment:
            # Bail out. The user will be given a helpful error message at
            # run-time and the application will exit with a non-0 exit
            # code without a distracting stack trace.
            return

        if run_environment in [
            RunEnvironment.RSM_DEV,
            RunEnvironment.RSM_SERVE,
        ]:
            # Only when running as part of `rsm dev run` do we need to bring up
            # a Resemble cluster instance in-memory.
            #
            # NOTE: we construct a 'Resemble' instance here so that it can
            # perform any process wide initialization as early as possible
            # (e.g., initializing multiprocessing before any threads are
            # created)
            self._rsm = Resemble()

    async def _run(self) -> int:
        """Runs the application and returns a status code indicating success
        or failure."""
        assert self._rsm is not None
        await self._rsm.start()

        name: Optional[str] = os.environ.get(ENVVAR_RSM_NAME)

        directory: Optional[str] = os.environ.get(ENVVAR_RSM_DIRECTORY)

        local_envoy: bool = os.environ.get(
            ENVVAR_RSM_LOCAL_ENVOY,
            'false',
        ).lower() == 'true'

        local_envoy_port: int = int(
            os.environ.get(
                ENVVAR_RSM_LOCAL_ENVOY_PORT, str(DEFAULT_SECURE_PORT)
            )
        )

        if name is not None:
            assert directory is not None

            try:
                await aiofiles.os.makedirs(directory)
            except FileExistsError:
                # Directory likely already exists since that's the
                # whole purpose of '--name' in the first place!
                pass

        try:
            config = await self._rsm.up(
                servicers=self._servicers,
                legacy_grpc_servicers=self._legacy_grpc_servicers,
                token_verifier=self._token_verifier,
                local_envoy=local_envoy,
                local_envoy_port=local_envoy_port,
                directory=directory,
                name=name,
            )

            if self._initialize is not None:
                await run_application_initializer(
                    application_id=config.application_id(),
                    initialize=self._initialize,
                    workflow=self._rsm.create_workflow(
                        name='initialize',
                        bearer_token=self._initialize_bearer_token,
                        # We pass a `seed` so that we can
                        # re-execute `initialize` idempotently!
                        idempotency_seed=uuid.uuid5(
                            uuid.NAMESPACE_DNS,
                            'anonymous.rsm.dev',
                        ),
                        idempotency_required=True,
                        idempotency_required_reason=
                        'Calls to mutators from within your initialize function must use idempotency',
                    )
                )

            # Wait forever unless we get cancelled!
            #
            # TODO(benh): have 'rsm.up()' return a tuple of (config,
            # future) so we can watch the future and if that ever
            # fails we should exit and return an error to the user.
            #
            # TODO(benh): also have 'rsm.up()' fail the future that it
            # returns to us if the local envoy that got started
            # happened to fail.
            forever = asyncio.Event()
            await forever.wait()
        finally:
            await self._rsm.stop()

        return 0

    async def _run_kubernetes(self) -> int:
        """Runs a single consensus in a Kubernetes-appropriate way.

        Blocks until cancelled, then returns a status code indicating success
        or failure.
        """

        try:
            serviceables: list[Serviceable] = []
            for servicer in self._servicers or []:
                serviceables.append(Serviceable.from_servicer_type(servicer))
            for legacy_grpc_servicer in self._legacy_grpc_servicers or []:
                serviceables.append(
                    Serviceable.from_servicer_type(legacy_grpc_servicer)
                )

            if len(serviceables) == 0:
                raise ValueError(
                    "No servicers were provided to the Application"
                )

            server = Server.create_on_k8s(
                serviceables=serviceables,
                listen_address=f'0.0.0.0:{USER_CONTAINER_GRPC_PORT}',
                initialize=self._initialize,
                initialize_bearer_token=self._initialize_bearer_token,
                token_verifier=self._token_verifier,
            )
            server_run_task = asyncio.create_task(server.run())

        except Exception as e:
            logger.error(f"Unexpected error while starting: {e}")
            # An unexpected error, by definition, is something that we didn't
            # see coming. It may have been caused by the user's code. Help them
            # (and us, if they file a bug report) debug it by printing the stack
            # trace.
            logger.error("Stack trace:", exc_info=True)
            return 1

        # Wait forever, or at least until the server gets shut down.
        await server_run_task

        return 0

    async def run(self) -> int:
        """Runs the application and returns a status code indicating success
        or failure."""

        colorama.init()

        try:
            run_environment = _detect_run_environment()
        except InvalidRunEnvironment:
            # We can't detect the run environment. Assume that the user is trying to
            # run the application locally, but doing it in a way we don't support.
            # Give a helpful error message pointing them to `rsm dev run`.
            terminal.error(
                "Please use 'rsm dev run' to run your application locally",
            )
            return 1

        if run_environment in [
            RunEnvironment.RSM_DEV,
            RunEnvironment.RSM_SERVE,
        ]:
            try:
                return await self._run()
            except InputError as e:
                _handle_input_error(e)
            except Exception as e:
                _handle_unknown_exception(e)

            return 1

        return await self._run_kubernetes()
