from typing import overload
import db
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.trace.database
import ghidra.trace.database.map
import ghidra.trace.database.space
import ghidra.trace.model
import ghidra.trace.model.map
import ghidra.trace.model.property
import ghidra.trace.model.stack
import ghidra.trace.model.thread
import ghidra.trace.util
import ghidra.util
import ghidra.util.database
import ghidra.util.database.spatial
import ghidra.util.database.spatial.rect
import java.io
import java.lang
import java.util
import java.util.concurrent.locks
import java.util.function


class AbstractDBTracePropertyMap(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMap, ghidra.trace.model.property.TracePropertyMap):





    class DBTraceSaveablePropertyMap(ghidra.trace.database.map.AbstractDBTracePropertyMap):




        def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager, __a8: java.lang.Class): ...



        def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        def dbError(self, __a0: java.io.IOException) -> None: ...

        def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

        def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

        def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

        def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

        def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

        def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

        def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

        def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

        def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delete(self) -> None: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        @overload
        def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

        @overload
        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        def getActiveMemorySpaces(self) -> java.util.Collection: ...

        def getActiveRegisterSpaces(self) -> java.util.Collection: ...

        def getActiveSpaces(self) -> java.util.Collection: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

        def getClass(self) -> java.lang.Class: ...

        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

        def getName(self) -> unicode: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

        def getTrace(self) -> ghidra.trace.database.DBTrace: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self, __a0: bool) -> None: ...

        def isEmpty(self) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        def readLock(self) -> java.util.concurrent.locks.Lock: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def writeLock(self) -> java.util.concurrent.locks.Lock: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class DBTraceLongPropertyMap(ghidra.trace.database.map.AbstractDBTracePropertyMap):




        def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager): ...



        def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        def dbError(self, __a0: java.io.IOException) -> None: ...

        def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

        def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

        def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

        def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

        def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

        def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

        def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

        def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

        def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delete(self) -> None: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        @overload
        def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

        @overload
        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        def getActiveMemorySpaces(self) -> java.util.Collection: ...

        def getActiveRegisterSpaces(self) -> java.util.Collection: ...

        def getActiveSpaces(self) -> java.util.Collection: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

        def getClass(self) -> java.lang.Class: ...

        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

        def getName(self) -> unicode: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

        def getTrace(self) -> ghidra.trace.database.DBTrace: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self, __a0: bool) -> None: ...

        def isEmpty(self) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        def readLock(self) -> java.util.concurrent.locks.Lock: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def writeLock(self) -> java.util.concurrent.locks.Lock: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class DBTraceStringPropertyMap(ghidra.trace.database.map.AbstractDBTracePropertyMap):




        def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager): ...



        def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        def dbError(self, __a0: java.io.IOException) -> None: ...

        def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

        def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

        def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

        def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

        def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

        def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

        def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

        def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

        def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delete(self) -> None: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        @overload
        def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

        @overload
        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        def getActiveMemorySpaces(self) -> java.util.Collection: ...

        def getActiveRegisterSpaces(self) -> java.util.Collection: ...

        def getActiveSpaces(self) -> java.util.Collection: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

        def getClass(self) -> java.lang.Class: ...

        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

        def getName(self) -> unicode: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

        def getTrace(self) -> ghidra.trace.database.DBTrace: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self, __a0: bool) -> None: ...

        def isEmpty(self) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        def readLock(self) -> java.util.concurrent.locks.Lock: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def writeLock(self) -> java.util.concurrent.locks.Lock: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class DBTraceSaveablePropertyMapEntry(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData):




        def __init__(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree, __a1: ghidra.util.database.DBCachedObjectStore, __a2: db.DBRecord, __a3: java.lang.Class): ...



        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def contains(self, __a0: ghidra.util.database.spatial.rect.Point2D) -> bool: ...

        @overload
        def contains(self, __a0: object, __a1: object) -> bool: ...

        def description(self) -> unicode: ...

        def doEquals(self, __a0: object) -> bool: ...

        def doHashCode(self) -> int: ...

        def enclosedBy(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.BoundingShape) -> bool: ...

        def equals(self, __a0: object) -> bool: ...

        def getArea(self) -> float: ...

        def getBounds(self) -> ghidra.util.database.spatial.BoundingShape: ...

        def getCenter(self) -> ghidra.util.database.spatial.rect.Point2D: ...

        def getClass(self) -> java.lang.Class: ...

        def getKey(self) -> long: ...

        def getLifespan(self) -> ghidra.trace.model.Lifespan: ...

        def getMargin(self) -> float: ...

        def getObjectKey(self) -> ghidra.util.database.ObjectKey: ...

        def getParentKey(self) -> long: ...

        def getRange(self) -> ghidra.program.model.address.AddressRange: ...

        def getShape(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def getSpace(self) -> ghidra.util.database.spatial.rect.EuclideanSpace2D: ...

        def getTableName(self) -> unicode: ...

        def getX1(self) -> object: ...

        def getX2(self) -> object: ...

        def getY1(self) -> object: ...

        def getY2(self) -> object: ...

        def hashCode(self) -> int: ...

        @overload
        def immutable(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long) -> ghidra.trace.model.TraceAddressSnapRange: ...

        @overload
        def immutable(self, __a0: object, __a1: object, __a2: object, __a3: object) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersects(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def isDeleted(self) -> bool: ...

        @overload
        def isDeleted(self, __a0: ghidra.util.Lock) -> bool: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def setInvalid(self) -> None: ...

        def setParentKey(self, __a0: long) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.util.database.spatial.BoundedShape) -> None: ...

        @overload
        def shapeEquals(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> bool: ...

        @overload
        def shapeEquals(self, __a0: ghidra.util.database.spatial.BoundedShape) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> ghidra.util.database.spatial.BoundingShape: ...

        @staticmethod
        def unionIterable(__a0: java.lang.Iterable) -> ghidra.util.database.spatial.BoundingShape: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class DBTraceLongPropertyMapEntry(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData):




        def __init__(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree, __a1: ghidra.util.database.DBCachedObjectStore, __a2: db.DBRecord): ...



        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def contains(self, __a0: ghidra.util.database.spatial.rect.Point2D) -> bool: ...

        @overload
        def contains(self, __a0: object, __a1: object) -> bool: ...

        def description(self) -> unicode: ...

        def doEquals(self, __a0: object) -> bool: ...

        def doHashCode(self) -> int: ...

        def enclosedBy(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.BoundingShape) -> bool: ...

        def equals(self, __a0: object) -> bool: ...

        def getArea(self) -> float: ...

        def getBounds(self) -> ghidra.util.database.spatial.BoundingShape: ...

        def getCenter(self) -> ghidra.util.database.spatial.rect.Point2D: ...

        def getClass(self) -> java.lang.Class: ...

        def getKey(self) -> long: ...

        def getLifespan(self) -> ghidra.trace.model.Lifespan: ...

        def getMargin(self) -> float: ...

        def getObjectKey(self) -> ghidra.util.database.ObjectKey: ...

        def getParentKey(self) -> long: ...

        def getRange(self) -> ghidra.program.model.address.AddressRange: ...

        def getShape(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def getSpace(self) -> ghidra.util.database.spatial.rect.EuclideanSpace2D: ...

        def getTableName(self) -> unicode: ...

        def getX1(self) -> object: ...

        def getX2(self) -> object: ...

        def getY1(self) -> object: ...

        def getY2(self) -> object: ...

        def hashCode(self) -> int: ...

        @overload
        def immutable(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long) -> ghidra.trace.model.TraceAddressSnapRange: ...

        @overload
        def immutable(self, __a0: object, __a1: object, __a2: object, __a3: object) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersects(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def isDeleted(self) -> bool: ...

        @overload
        def isDeleted(self, __a0: ghidra.util.Lock) -> bool: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def setInvalid(self) -> None: ...

        def setParentKey(self, __a0: long) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.util.database.spatial.BoundedShape) -> None: ...

        @overload
        def shapeEquals(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> bool: ...

        @overload
        def shapeEquals(self, __a0: ghidra.util.database.spatial.BoundedShape) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> ghidra.util.database.spatial.BoundingShape: ...

        @staticmethod
        def unionIterable(__a0: java.lang.Iterable) -> ghidra.util.database.spatial.BoundingShape: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class DBTraceVoidPropertyMap(ghidra.trace.database.map.AbstractDBTracePropertyMap):




        def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager): ...



        def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        def dbError(self, __a0: java.io.IOException) -> None: ...

        def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

        def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

        def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

        def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

        def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

        def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

        def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

        def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

        def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delete(self) -> None: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        @overload
        def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

        @overload
        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        def getActiveMemorySpaces(self) -> java.util.Collection: ...

        def getActiveRegisterSpaces(self) -> java.util.Collection: ...

        def getActiveSpaces(self) -> java.util.Collection: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

        def getClass(self) -> java.lang.Class: ...

        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

        def getName(self) -> unicode: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

        def getTrace(self) -> ghidra.trace.database.DBTrace: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self, __a0: bool) -> None: ...

        def isEmpty(self) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        def readLock(self) -> java.util.concurrent.locks.Lock: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def writeLock(self) -> java.util.concurrent.locks.Lock: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class DBTraceIntPropertyMapEntry(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData):




        def __init__(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree, __a1: ghidra.util.database.DBCachedObjectStore, __a2: db.DBRecord): ...



        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def contains(self, __a0: ghidra.util.database.spatial.rect.Point2D) -> bool: ...

        @overload
        def contains(self, __a0: object, __a1: object) -> bool: ...

        def description(self) -> unicode: ...

        def doEquals(self, __a0: object) -> bool: ...

        def doHashCode(self) -> int: ...

        def enclosedBy(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.BoundingShape) -> bool: ...

        def equals(self, __a0: object) -> bool: ...

        def getArea(self) -> float: ...

        def getBounds(self) -> ghidra.util.database.spatial.BoundingShape: ...

        def getCenter(self) -> ghidra.util.database.spatial.rect.Point2D: ...

        def getClass(self) -> java.lang.Class: ...

        def getKey(self) -> long: ...

        def getLifespan(self) -> ghidra.trace.model.Lifespan: ...

        def getMargin(self) -> float: ...

        def getObjectKey(self) -> ghidra.util.database.ObjectKey: ...

        def getParentKey(self) -> long: ...

        def getRange(self) -> ghidra.program.model.address.AddressRange: ...

        def getShape(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def getSpace(self) -> ghidra.util.database.spatial.rect.EuclideanSpace2D: ...

        def getTableName(self) -> unicode: ...

        def getX1(self) -> object: ...

        def getX2(self) -> object: ...

        def getY1(self) -> object: ...

        def getY2(self) -> object: ...

        def hashCode(self) -> int: ...

        @overload
        def immutable(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long) -> ghidra.trace.model.TraceAddressSnapRange: ...

        @overload
        def immutable(self, __a0: object, __a1: object, __a2: object, __a3: object) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersects(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def isDeleted(self) -> bool: ...

        @overload
        def isDeleted(self, __a0: ghidra.util.Lock) -> bool: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def setInvalid(self) -> None: ...

        def setParentKey(self, __a0: long) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.util.database.spatial.BoundedShape) -> None: ...

        @overload
        def shapeEquals(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> bool: ...

        @overload
        def shapeEquals(self, __a0: ghidra.util.database.spatial.BoundedShape) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> ghidra.util.database.spatial.BoundingShape: ...

        @staticmethod
        def unionIterable(__a0: java.lang.Iterable) -> ghidra.util.database.spatial.BoundingShape: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class DBTracePropertyMapSpace(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace, ghidra.trace.model.property.TracePropertyMapSpace):




        def __init__(self, __a0: ghidra.trace.database.map.AbstractDBTracePropertyMap, __a1: unicode, __a2: ghidra.util.database.DBCachedObjectStoreFactory, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.program.model.address.AddressSpace, __a5: ghidra.trace.model.thread.TraceThread, __a6: int, __a7: java.lang.Class, __a8: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMap.DBTraceAddressSnapRangePropertyMapDataFactory): ...



        @overload
        def assertInSpace(self, __a0: ghidra.program.model.address.Address) -> long: ...

        @overload
        def assertInSpace(self, __a0: ghidra.program.model.address.AddressRange) -> None: ...

        def checkIntegrity(self) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.lang.Register) -> None: ...

        @staticmethod
        def create(__a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.model.thread.TraceThread, __a2: int) -> ghidra.trace.database.space.DBTraceSpaceKey: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def explainLanguages(self, __a0: ghidra.program.model.address.AddressSpace) -> unicode: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getAddressSpace(self) -> ghidra.program.model.address.AddressSpace: ...

        def getClass(self) -> java.lang.Class: ...

        def getDataByKey(self, __a0: long) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData: ...

        @overload
        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        @overload
        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.lang.Register) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getFrameLevel(self) -> int: ...

        def getThread(self) -> ghidra.trace.model.thread.TraceThread: ...

        def getTrace(self) -> ghidra.trace.model.Trace: ...

        def getUserIndex(self, __a0: java.lang.Class, __a1: ghidra.util.database.DBObjectColumn) -> ghidra.util.database.DBCachedObjectIndex: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self) -> None: ...

        def isEmpty(self) -> bool: ...

        def isMySpace(self, __a0: ghidra.program.model.address.AddressSpace) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.lang.Register, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toAddress(self, __a0: long) -> ghidra.program.model.address.Address: ...

        def toOverlay(self, __a0: ghidra.program.model.address.Address) -> ghidra.program.model.address.Address: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        @property
        def trace(self) -> ghidra.trace.model.Trace: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class SaveableDBFieldCodec(ghidra.util.database.DBCachedObjectStoreFactory.AbstractDBFieldCodec):




        def __init__(self, __a0: java.lang.Class, __a1: java.lang.reflect.Field, __a2: int): ...



        def encodeField(self, __a0: object) -> db.Field: ...

        def equals(self, __a0: object) -> bool: ...

        def getClass(self) -> java.lang.Class: ...

        def getFieldType(self) -> java.lang.Class: ...

        def getObjectType(self) -> java.lang.Class: ...

        def getValue(self, __a0: ghidra.util.database.DBAnnotatedObject) -> object: ...

        def getValueType(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def load(self, __a0: ghidra.util.database.DBAnnotatedObject, __a1: db.DBRecord) -> None: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        @overload
        def store(self, __a0: ghidra.util.Saveable, __a1: db.BinaryField) -> None: ...

        @overload
        def store(self, __a0: ghidra.util.database.DBAnnotatedObject, __a1: db.DBRecord) -> None: ...

        @overload
        def store(self, __a0: object, __a1: db.Field) -> None: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class DBTraceStringPropertyMapEntry(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData):




        def __init__(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree, __a1: ghidra.util.database.DBCachedObjectStore, __a2: db.DBRecord): ...



        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def contains(self, __a0: ghidra.util.database.spatial.rect.Point2D) -> bool: ...

        @overload
        def contains(self, __a0: object, __a1: object) -> bool: ...

        def description(self) -> unicode: ...

        def doEquals(self, __a0: object) -> bool: ...

        def doHashCode(self) -> int: ...

        def enclosedBy(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.BoundingShape) -> bool: ...

        def equals(self, __a0: object) -> bool: ...

        def getArea(self) -> float: ...

        def getBounds(self) -> ghidra.util.database.spatial.BoundingShape: ...

        def getCenter(self) -> ghidra.util.database.spatial.rect.Point2D: ...

        def getClass(self) -> java.lang.Class: ...

        def getKey(self) -> long: ...

        def getLifespan(self) -> ghidra.trace.model.Lifespan: ...

        def getMargin(self) -> float: ...

        def getObjectKey(self) -> ghidra.util.database.ObjectKey: ...

        def getParentKey(self) -> long: ...

        def getRange(self) -> ghidra.program.model.address.AddressRange: ...

        def getShape(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def getSpace(self) -> ghidra.util.database.spatial.rect.EuclideanSpace2D: ...

        def getTableName(self) -> unicode: ...

        def getX1(self) -> object: ...

        def getX2(self) -> object: ...

        def getY1(self) -> object: ...

        def getY2(self) -> object: ...

        def hashCode(self) -> int: ...

        @overload
        def immutable(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long) -> ghidra.trace.model.TraceAddressSnapRange: ...

        @overload
        def immutable(self, __a0: object, __a1: object, __a2: object, __a3: object) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersects(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def isDeleted(self) -> bool: ...

        @overload
        def isDeleted(self, __a0: ghidra.util.Lock) -> bool: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def setInvalid(self) -> None: ...

        def setParentKey(self, __a0: long) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.util.database.spatial.BoundedShape) -> None: ...

        @overload
        def shapeEquals(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> bool: ...

        @overload
        def shapeEquals(self, __a0: ghidra.util.database.spatial.BoundedShape) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> ghidra.util.database.spatial.BoundingShape: ...

        @staticmethod
        def unionIterable(__a0: java.lang.Iterable) -> ghidra.util.database.spatial.BoundingShape: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...






    class DBTraceIntPropertyMap(ghidra.trace.database.map.AbstractDBTracePropertyMap):




        def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager): ...



        def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

        @overload
        def clear(self) -> None: ...

        @overload
        def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

        def dbError(self, __a0: java.io.IOException) -> None: ...

        def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

        def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

        def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

        def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

        def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        @overload
        def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

        def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

        @overload
        def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

        def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

        def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

        def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

        def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

        def delete(self) -> None: ...

        def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

        def deleteValue(self, __a0: object) -> None: ...

        @staticmethod
        def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

        def entries(self) -> java.util.Collection: ...

        def equals(self, __a0: object) -> bool: ...

        def firstEntry(self) -> java.util.Map.Entry: ...

        def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def firstValue(self) -> object: ...

        @overload
        def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

        @overload
        def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

        def getActiveMemorySpaces(self) -> java.util.Collection: ...

        def getActiveRegisterSpaces(self) -> java.util.Collection: ...

        def getActiveSpaces(self) -> java.util.Collection: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

        @overload
        def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

        def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

        def getClass(self) -> java.lang.Class: ...

        def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

        def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

        def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

        def getName(self) -> unicode: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

        @overload
        def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

        def getTrace(self) -> ghidra.trace.database.DBTrace: ...

        def getValueClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCache(self, __a0: bool) -> None: ...

        def isEmpty(self) -> bool: ...

        def keys(self) -> java.util.Collection: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def orderedEntries(self) -> java.util.Collection: ...

        def orderedKeys(self) -> java.util.Collection: ...

        def orderedValues(self) -> java.util.Collection: ...

        @overload
        def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

        @overload
        def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

        def readLock(self) -> java.util.concurrent.locks.Lock: ...

        @overload
        def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

        @overload
        def remove(self, __a0: java.util.Map.Entry) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

        @overload
        def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

        @overload
        def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

        def size(self) -> int: ...

        def toString(self) -> unicode: ...

        def values(self) -> java.util.Collection: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def writeLock(self) -> java.util.concurrent.locks.Lock: ...

        @property
        def valueClass(self) -> java.lang.Class: ...




    class DBTraceVoidPropertyMapEntry(ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData):




        def __init__(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree, __a1: ghidra.util.database.DBCachedObjectStore, __a2: db.DBRecord): ...



        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaIntersection(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeAreaUnionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> float: ...

        @overload
        def computeCentroidDistance(self, __a0: ghidra.util.database.spatial.BoundingShape) -> float: ...

        @overload
        def contains(self, __a0: ghidra.util.database.spatial.rect.Point2D) -> bool: ...

        @overload
        def contains(self, __a0: object, __a1: object) -> bool: ...

        def description(self) -> unicode: ...

        def doEquals(self, __a0: object) -> bool: ...

        def doHashCode(self) -> int: ...

        def enclosedBy(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def encloses(self, __a0: ghidra.util.database.spatial.BoundingShape) -> bool: ...

        def equals(self, __a0: object) -> bool: ...

        def getArea(self) -> float: ...

        def getBounds(self) -> ghidra.util.database.spatial.BoundingShape: ...

        def getCenter(self) -> ghidra.util.database.spatial.rect.Point2D: ...

        def getClass(self) -> java.lang.Class: ...

        def getKey(self) -> long: ...

        def getLifespan(self) -> ghidra.trace.model.Lifespan: ...

        def getMargin(self) -> float: ...

        def getObjectKey(self) -> ghidra.util.database.ObjectKey: ...

        def getParentKey(self) -> long: ...

        def getRange(self) -> ghidra.program.model.address.AddressRange: ...

        def getShape(self) -> ghidra.util.database.spatial.BoundedShape: ...

        def getSpace(self) -> ghidra.util.database.spatial.rect.EuclideanSpace2D: ...

        def getTableName(self) -> unicode: ...

        def getX1(self) -> object: ...

        def getX2(self) -> object: ...

        def getY1(self) -> object: ...

        def getY2(self) -> object: ...

        def hashCode(self) -> int: ...

        @overload
        def immutable(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long) -> ghidra.trace.model.TraceAddressSnapRange: ...

        @overload
        def immutable(self, __a0: object, __a1: object, __a2: object, __a3: object) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersection(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        def intersects(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> bool: ...

        @overload
        def isDeleted(self) -> bool: ...

        @overload
        def isDeleted(self, __a0: ghidra.util.Lock) -> bool: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def setInvalid(self) -> None: ...

        def setParentKey(self, __a0: long) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> None: ...

        @overload
        def setShape(self, __a0: ghidra.util.database.spatial.BoundedShape) -> None: ...

        @overload
        def shapeEquals(self, __a0: ghidra.trace.model.TraceAddressSnapRange) -> bool: ...

        @overload
        def shapeEquals(self, __a0: ghidra.util.database.spatial.BoundedShape) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.rect.Rectangle2D) -> ghidra.util.database.spatial.rect.Rectangle2D: ...

        @overload
        def unionBounds(self, __a0: ghidra.util.database.spatial.BoundingShape) -> ghidra.util.database.spatial.BoundingShape: ...

        @staticmethod
        def unionIterable(__a0: java.lang.Iterable) -> ghidra.util.database.spatial.BoundingShape: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...



    def __init__(self, __a0: unicode, __a1: db.DBHandle, __a2: ghidra.framework.data.OpenMode, __a3: java.util.concurrent.locks.ReadWriteLock, __a4: ghidra.util.task.TaskMonitor, __a5: ghidra.program.model.lang.Language, __a6: ghidra.trace.database.DBTrace, __a7: ghidra.trace.database.thread.DBTraceThreadManager, __a8: java.lang.Class, __a9: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMap.DBTraceAddressSnapRangePropertyMapDataFactory): ...



    def checkIsInMemory(self, __a0: ghidra.program.model.address.AddressSpace) -> None: ...

    @overload
    def clear(self) -> None: ...

    @overload
    def clear(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> bool: ...

    def dbError(self, __a0: java.io.IOException) -> None: ...

    def delegateAddressSet(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> ghidra.program.model.address.AddressSetView: ...

    def delegateAny(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcPredicate) -> bool: ...

    def delegateCollection(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.Collection: ...

    def delegateDeleteB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

    def delegateDeleteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

    def delegateFirst(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> object: ...

    def delegateHashSet(self, __a0: java.lang.Iterable, __a1: java.util.function.Function) -> java.util.HashSet: ...

    @overload
    def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

    @overload
    def delegateRead(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: object) -> object: ...

    def delegateReadB(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.Predicate, __a2: bool) -> bool: ...

    @overload
    def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: int) -> int: ...

    @overload
    def delegateReadI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction, __a2: java.util.function.IntSupplier) -> int: ...

    def delegateReadOr(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction, __a2: ghidra.trace.database.space.DBTraceDelegatingManager.ExcSupplier) -> object: ...

    def delegateWrite(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcFunction) -> object: ...

    def delegateWriteAll(self, __a0: java.lang.Iterable, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

    def delegateWriteI(self, __a0: ghidra.program.model.address.AddressSpace, __a1: java.util.function.ToIntFunction) -> int: ...

    def delegateWriteV(self, __a0: ghidra.program.model.address.AddressSpace, __a1: ghidra.trace.database.space.DBTraceDelegatingManager.ExcConsumer) -> None: ...

    def delete(self) -> None: ...

    def deleteData(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.AbstractDBTraceAddressSnapRangePropertyMapData) -> None: ...

    def deleteValue(self, __a0: object) -> None: ...

    @staticmethod
    def emptyMap() -> ghidra.util.database.spatial.SpatialMap: ...

    def entries(self) -> java.util.Collection: ...

    def equals(self, __a0: object) -> bool: ...

    def firstEntry(self) -> java.util.Map.Entry: ...

    def firstKey(self) -> ghidra.util.database.spatial.BoundedShape: ...

    def firstValue(self) -> object: ...

    @overload
    def get(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.database.space.DBTraceSpaceBased: ...

    @overload
    def get(self, __a0: long, __a1: ghidra.program.model.address.Address) -> object: ...

    def getActiveMemorySpaces(self) -> java.util.Collection: ...

    def getActiveRegisterSpaces(self) -> java.util.Collection: ...

    def getActiveSpaces(self) -> java.util.Collection: ...

    @overload
    def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan) -> ghidra.program.model.address.AddressSetView: ...

    @overload
    def getAddressSetView(self, __a0: ghidra.trace.model.Lifespan, __a1: java.util.function.Predicate) -> ghidra.program.model.address.AddressSetView: ...

    def getBaseLanguage(self) -> ghidra.program.model.lang.Language: ...

    def getClass(self) -> java.lang.Class: ...

    def getEntries(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange) -> java.util.Collection: ...

    def getEntry(self, __a0: long, __a1: ghidra.program.model.address.Address) -> java.util.Map.Entry: ...

    def getForSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

    def getLock(self) -> java.util.concurrent.locks.ReadWriteLock: ...

    def getName(self) -> unicode: ...

    @overload
    def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

    @overload
    def getPropertyMapRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

    @overload
    def getPropertyMapSpace(self, __a0: ghidra.program.model.address.AddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

    @overload
    def getPropertyMapSpace(self, __a0: ghidra.trace.util.TraceAddressSpace, __a1: bool) -> ghidra.trace.model.property.TracePropertyMapSpace: ...

    @overload
    def getRegisterSpace(self, __a0: ghidra.trace.model.stack.TraceStackFrame, __a1: bool) -> ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapSpace: ...

    @overload
    def getRegisterSpace(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: bool) -> ghidra.trace.model.map.TraceAddressSnapRangePropertyMapSpace: ...

    def getTrace(self) -> ghidra.trace.database.DBTrace: ...

    def getValueClass(self) -> java.lang.Class: ...

    def hashCode(self) -> int: ...

    def invalidateCache(self, __a0: bool) -> None: ...

    def isEmpty(self) -> bool: ...

    def keys(self) -> java.util.Collection: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def orderedEntries(self) -> java.util.Collection: ...

    def orderedKeys(self) -> java.util.Collection: ...

    def orderedValues(self) -> java.util.Collection: ...

    @overload
    def put(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> object: ...

    @overload
    def put(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> object: ...

    @overload
    def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

    @overload
    def put(self, __a0: ghidra.program.model.address.AddressRange, __a1: ghidra.trace.model.Lifespan, __a2: object) -> object: ...

    @overload
    def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: object) -> object: ...

    @overload
    def put(self, __a0: ghidra.program.model.address.Address, __a1: ghidra.program.model.address.Address, __a2: long, __a3: long, __a4: object) -> object: ...

    def readLock(self) -> java.util.concurrent.locks.Lock: ...

    @overload
    def reduce(self, __a0: ghidra.trace.database.map.DBTraceAddressSnapRangePropertyMapTree.TraceAddressSnapRangeQuery) -> ghidra.util.database.spatial.SpatialMap: ...

    @overload
    def reduce(self, __a0: object) -> ghidra.util.database.spatial.SpatialMap: ...

    @overload
    def remove(self, __a0: java.util.Map.Entry) -> bool: ...

    @overload
    def remove(self, __a0: ghidra.trace.model.TraceAddressSnapRange, __a1: object) -> bool: ...

    @overload
    def remove(self, __a0: ghidra.util.database.spatial.BoundedShape, __a1: object) -> bool: ...

    @overload
    def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.Address, __a2: object) -> None: ...

    @overload
    def set(self, __a0: ghidra.trace.model.Lifespan, __a1: ghidra.program.model.address.AddressRange, __a2: object) -> None: ...

    def size(self) -> int: ...

    def toString(self) -> unicode: ...

    def values(self) -> java.util.Collection: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    def writeLock(self) -> java.util.concurrent.locks.Lock: ...

