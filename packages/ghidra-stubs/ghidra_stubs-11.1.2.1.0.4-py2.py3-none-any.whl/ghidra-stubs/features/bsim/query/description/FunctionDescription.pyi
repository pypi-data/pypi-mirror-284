from typing import List
from typing import overload
import generic.lsh.vector
import ghidra.features.bsim.query.description
import ghidra.xml
import java.io
import java.lang
import java.util


class FunctionDescription(object, java.lang.Comparable):





    class Update(object):
        flags: bool
        function_name: bool
        update: ghidra.features.bsim.query.description.FunctionDescription



        def __init__(self): ...



        def equals(self, __a0: object) -> bool: ...

        def getClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...



    def __init__(self, __a0: ghidra.features.bsim.query.description.ExecutableRecord, __a1: unicode, __a2: long): ...



    @overload
    def compareTo(self, __a0: ghidra.features.bsim.query.description.FunctionDescription) -> int: ...

    @overload
    def compareTo(self, __a0: object) -> int: ...

    @staticmethod
    def createAddressToFunctionMap(__a0: java.util.Iterator) -> java.util.Map: ...

    def diffForUpdate(self, __a0: ghidra.features.bsim.query.description.FunctionDescription.Update, __a1: ghidra.features.bsim.query.description.FunctionDescription) -> bool: ...

    def equals(self, __a0: object) -> bool: ...

    @staticmethod
    def generateUpdates(__a0: java.util.Iterator, __a1: java.util.Map, __a2: List[object]) -> List[object]: ...

    def getAddress(self) -> long: ...

    def getCallgraphRecord(self) -> List[object]: ...

    def getClass(self) -> java.lang.Class: ...

    def getExecutableRecord(self) -> ghidra.features.bsim.query.description.ExecutableRecord: ...

    def getFlags(self) -> int: ...

    def getFunctionName(self) -> unicode: ...

    def getId(self) -> ghidra.features.bsim.query.description.RowKey: ...

    def getSignatureRecord(self) -> ghidra.features.bsim.query.description.SignatureRecord: ...

    def getVectorId(self) -> long: ...

    def hashCode(self) -> int: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def printRaw(self) -> unicode: ...

    @staticmethod
    def restoreXml(__a0: ghidra.xml.XmlPullParser, __a1: generic.lsh.vector.LSHVectorFactory, __a2: ghidra.features.bsim.query.description.DescriptionManager, __a3: ghidra.features.bsim.query.description.ExecutableRecord) -> ghidra.features.bsim.query.description.FunctionDescription: ...

    def saveXml(self, __a0: java.io.Writer) -> None: ...

    def setSignatureRecord(self, __a0: ghidra.features.bsim.query.description.SignatureRecord) -> None: ...

    def sortCallgraph(self) -> None: ...

    def toString(self) -> unicode: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @property
    def address(self) -> long: ...

    @property
    def callgraphRecord(self) -> List[object]: ...

    @property
    def executableRecord(self) -> ghidra.features.bsim.query.description.ExecutableRecord: ...

    @property
    def flags(self) -> int: ...

    @property
    def functionName(self) -> unicode: ...

    @property
    def id(self) -> ghidra.features.bsim.query.description.RowKey: ...

    @property
    def signatureRecord(self) -> ghidra.features.bsim.query.description.SignatureRecord: ...

    @signatureRecord.setter
    def signatureRecord(self, value: ghidra.features.bsim.query.description.SignatureRecord) -> None: ...

    @property
    def vectorId(self) -> long: ...