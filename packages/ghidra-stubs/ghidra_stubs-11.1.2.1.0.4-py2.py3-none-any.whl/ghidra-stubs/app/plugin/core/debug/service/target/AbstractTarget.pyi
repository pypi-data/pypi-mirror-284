from typing import List
from typing import overload
import docking
import ghidra.dbg.target
import ghidra.debug.api.target
import ghidra.debug.api.tracemgr
import ghidra.framework.plugintool
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.trace.model
import ghidra.trace.model.breakpoint
import ghidra.trace.model.guest
import ghidra.trace.model.stack
import ghidra.trace.model.target
import ghidra.trace.model.thread
import ghidra.util.task
import java.lang
import java.util
import java.util.concurrent


class AbstractTarget(object, ghidra.debug.api.target.Target):
    TIMEOUT_MILLIS: long = 0x2710L



    def __init__(self, __a0: ghidra.framework.plugintool.PluginTool): ...



    def activate(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates, __a1: ghidra.debug.api.tracemgr.DebuggerCoordinates) -> None: ...

    def activateAsync(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates, __a1: ghidra.debug.api.tracemgr.DebuggerCoordinates) -> java.util.concurrent.CompletableFuture: ...

    def collectActions(self, __a0: ghidra.debug.api.target.ActionName, __a1: docking.ActionContext) -> java.util.Map: ...

    def deleteBreakpoint(self, __a0: ghidra.trace.model.breakpoint.TraceBreakpoint) -> None: ...

    def deleteBreakpointAsync(self, __a0: ghidra.trace.model.breakpoint.TraceBreakpoint) -> java.util.concurrent.CompletableFuture: ...

    def describe(self) -> unicode: ...

    def disconnect(self) -> None: ...

    def disconnectAsync(self) -> java.util.concurrent.CompletableFuture: ...

    def equals(self, __a0: object) -> bool: ...

    def execute(self, __a0: unicode, __a1: bool) -> unicode: ...

    def executeAsync(self, __a0: unicode, __a1: bool) -> java.util.concurrent.CompletableFuture: ...

    def forceTerminate(self) -> None: ...

    def forceTerminateAsync(self) -> java.util.concurrent.CompletableFuture: ...

    def getClass(self) -> java.lang.Class: ...

    def getFocus(self) -> ghidra.trace.model.target.TraceObjectKeyPath: ...

    def getSnap(self) -> long: ...

    def getStackFrameForSuccessor(self, __a0: ghidra.trace.model.target.TraceObjectKeyPath) -> ghidra.trace.model.stack.TraceStackFrame: ...

    def getSupportedBreakpointKinds(self) -> java.util.Set: ...

    def getThreadExecutionState(self, __a0: ghidra.trace.model.thread.TraceThread) -> ghidra.dbg.target.TargetExecutionStateful.TargetExecutionState: ...

    def getThreadForSuccessor(self, __a0: ghidra.trace.model.target.TraceObjectKeyPath) -> ghidra.trace.model.thread.TraceThread: ...

    def getTool(self) -> ghidra.framework.plugintool.PluginTool: ...

    def getTrace(self) -> ghidra.trace.model.Trace: ...

    def hashCode(self) -> int: ...

    def invalidateMemoryCaches(self) -> None: ...

    def invalidateMemoryCachesAsync(self) -> java.util.concurrent.CompletableFuture: ...

    def isBreakpointValid(self, __a0: ghidra.trace.model.breakpoint.TraceBreakpoint) -> bool: ...

    def isSupportsFocus(self) -> bool: ...

    def isValid(self) -> bool: ...

    def isVariableExists(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.Address, __a4: int) -> bool: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def placeBreakpoint(self, __a0: ghidra.program.model.address.AddressRange, __a1: java.util.Set, __a2: unicode, __a3: unicode) -> None: ...

    def placeBreakpointAsync(self, __a0: ghidra.program.model.address.AddressRange, __a1: java.util.Set, __a2: unicode, __a3: unicode) -> java.util.concurrent.CompletableFuture: ...

    def readMemory(self, __a0: ghidra.program.model.address.AddressSetView, __a1: ghidra.util.task.TaskMonitor) -> None: ...

    def readMemoryAsync(self, __a0: ghidra.program.model.address.AddressSetView, __a1: ghidra.util.task.TaskMonitor) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def readRegisters(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.AddressSetView) -> None: ...

    @overload
    def readRegisters(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: java.util.Set) -> None: ...

    @overload
    def readRegistersAsync(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.AddressSetView) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def readRegistersAsync(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: java.util.Set) -> java.util.concurrent.CompletableFuture: ...

    def toString(self) -> unicode: ...

    def toggleBreakpoint(self, __a0: ghidra.trace.model.breakpoint.TraceBreakpoint, __a1: bool) -> None: ...

    def toggleBreakpointAsync(self, __a0: ghidra.trace.model.breakpoint.TraceBreakpoint, __a1: bool) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    def writeMemory(self, __a0: ghidra.program.model.address.Address, __a1: List[int]) -> None: ...

    def writeMemoryAsync(self, __a0: ghidra.program.model.address.Address, __a1: List[int]) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def writeRegister(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.lang.RegisterValue) -> None: ...

    @overload
    def writeRegister(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.Address, __a4: List[int]) -> None: ...

    @overload
    def writeRegisterAsync(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.lang.RegisterValue) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def writeRegisterAsync(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.Address, __a4: List[int]) -> java.util.concurrent.CompletableFuture: ...

    def writeVariable(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.Address, __a4: List[int]) -> None: ...

    def writeVariableAsync(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: ghidra.program.model.address.Address, __a4: List[int]) -> java.util.concurrent.CompletableFuture: ...

    @property
    def focus(self) -> ghidra.trace.model.target.TraceObjectKeyPath: ...

    @property
    def snap(self) -> long: ...

    @property
    def supportedBreakpointKinds(self) -> java.util.Set: ...

    @property
    def supportsFocus(self) -> bool: ...

    @property
    def tool(self) -> ghidra.framework.plugintool.PluginTool: ...

    @property
    def trace(self) -> ghidra.trace.model.Trace: ...

    @property
    def valid(self) -> bool: ...