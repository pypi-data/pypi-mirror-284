from typing import List
from typing import overload
import ghidra.async
import ghidra.dbg
import ghidra.dbg.error
import ghidra.dbg.target
import ghidra.program.model.address
import ghidra.util
import java.lang
import java.util
import java.util.concurrent
import java.util.function


class DebugModelConventions(java.lang.Enum):





    class AsyncAttribute(ghidra.async.AsyncReference, ghidra.dbg.DebuggerModelListener):




        def __init__(self, __a0: ghidra.dbg.target.TargetObject, __a1: unicode): ...



        def addChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def attributesChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def breakpointHit(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: ghidra.dbg.target.TargetStackFrame, __a3: ghidra.dbg.target.TargetBreakpointSpec, __a4: ghidra.dbg.target.TargetBreakpointLocation) -> None: ...

        def catastrophic(self, __a0: java.lang.Throwable) -> None: ...

        def compute(self, __a0: java.util.function.Function, __a1: object) -> object: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: unicode) -> None: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: List[int]) -> None: ...

        def created(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def debounced(self, __a0: ghidra.async.AsyncTimer, __a1: long) -> ghidra.async.AsyncReference: ...

        @overload
        def dispose(self) -> None: ...

        @overload
        def dispose(self, __a0: java.lang.Throwable) -> None: ...

        def elementsChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def equals(self, __a0: object) -> bool: ...

        def event(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetThread, __a2: ghidra.dbg.target.TargetEventScope.TargetEventType, __a3: unicode, __a4: List[object]) -> None: ...

        def filter(self, __a0: ghidra.async.AsyncReference.FilterFunction) -> None: ...

        def get(self) -> object: ...

        def getClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCacheRequested(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def invalidated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: unicode) -> None: ...

        def memoryReadError(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.AddressRange, __a2: ghidra.dbg.error.DebuggerMemoryAccessException) -> None: ...

        def memoryUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.Address, __a2: List[int]) -> None: ...

        def modelClosed(self, __a0: ghidra.dbg.DebuggerModelClosedReason) -> None: ...

        def modelOpened(self) -> None: ...

        def modelStateChanged(self) -> None: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def registersUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Map) -> None: ...

        def removeChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def rootAdded(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def set(self, __a0: object, __a1: object) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def waitChanged(self) -> java.util.concurrent.CompletableFuture: ...

        def waitUntil(self, __a0: java.util.function.Predicate) -> java.util.concurrent.CompletableFuture: ...

        def waitValue(self, __a0: object) -> java.util.concurrent.CompletableFuture: ...






    class AsyncAccess(ghidra.dbg.DebugModelConventions.AsyncAttribute):




        def __init__(self, __a0: ghidra.dbg.target.TargetAccessConditioned): ...



        def addChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def attributesChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def breakpointHit(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: ghidra.dbg.target.TargetStackFrame, __a3: ghidra.dbg.target.TargetBreakpointSpec, __a4: ghidra.dbg.target.TargetBreakpointLocation) -> None: ...

        def catastrophic(self, __a0: java.lang.Throwable) -> None: ...

        def compute(self, __a0: java.util.function.Function, __a1: object) -> object: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: unicode) -> None: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: List[int]) -> None: ...

        def created(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def debounced(self, __a0: ghidra.async.AsyncTimer, __a1: long) -> ghidra.async.AsyncReference: ...

        @overload
        def dispose(self) -> None: ...

        @overload
        def dispose(self, __a0: java.lang.Throwable) -> None: ...

        def elementsChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def equals(self, __a0: object) -> bool: ...

        def event(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetThread, __a2: ghidra.dbg.target.TargetEventScope.TargetEventType, __a3: unicode, __a4: List[object]) -> None: ...

        def filter(self, __a0: ghidra.async.AsyncReference.FilterFunction) -> None: ...

        def get(self) -> object: ...

        def getClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCacheRequested(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def invalidated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: unicode) -> None: ...

        def memoryReadError(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.AddressRange, __a2: ghidra.dbg.error.DebuggerMemoryAccessException) -> None: ...

        def memoryUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.Address, __a2: List[int]) -> None: ...

        def modelClosed(self, __a0: ghidra.dbg.DebuggerModelClosedReason) -> None: ...

        def modelOpened(self) -> None: ...

        def modelStateChanged(self) -> None: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def registersUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Map) -> None: ...

        def removeChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def rootAdded(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def set(self, __a0: object, __a1: object) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def waitChanged(self) -> java.util.concurrent.CompletableFuture: ...

        def waitUntil(self, __a0: java.util.function.Predicate) -> java.util.concurrent.CompletableFuture: ...

        def waitValue(self, __a0: object) -> java.util.concurrent.CompletableFuture: ...






    class AsyncState(ghidra.dbg.DebugModelConventions.AsyncAttribute):




        def __init__(self, __a0: ghidra.dbg.target.TargetExecutionStateful): ...



        def addChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def attributesChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def breakpointHit(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: ghidra.dbg.target.TargetStackFrame, __a3: ghidra.dbg.target.TargetBreakpointSpec, __a4: ghidra.dbg.target.TargetBreakpointLocation) -> None: ...

        def catastrophic(self, __a0: java.lang.Throwable) -> None: ...

        def compute(self, __a0: java.util.function.Function, __a1: object) -> object: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: unicode) -> None: ...

        @overload
        def consoleOutput(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetConsole.Channel, __a2: List[int]) -> None: ...

        def created(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def debounced(self, __a0: ghidra.async.AsyncTimer, __a1: long) -> ghidra.async.AsyncReference: ...

        @overload
        def dispose(self) -> None: ...

        @overload
        def dispose(self, __a0: java.lang.Throwable) -> None: ...

        def elementsChanged(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Collection, __a2: java.util.Map) -> None: ...

        def equals(self, __a0: object) -> bool: ...

        def event(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetThread, __a2: ghidra.dbg.target.TargetEventScope.TargetEventType, __a3: unicode, __a4: List[object]) -> None: ...

        def filter(self, __a0: ghidra.async.AsyncReference.FilterFunction) -> None: ...

        def get(self) -> object: ...

        def getClass(self) -> java.lang.Class: ...

        def hashCode(self) -> int: ...

        def invalidateCacheRequested(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def invalidated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.dbg.target.TargetObject, __a2: unicode) -> None: ...

        def memoryReadError(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.AddressRange, __a2: ghidra.dbg.error.DebuggerMemoryAccessException) -> None: ...

        def memoryUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: ghidra.program.model.address.Address, __a2: List[int]) -> None: ...

        def modelClosed(self, __a0: ghidra.dbg.DebuggerModelClosedReason) -> None: ...

        def modelOpened(self) -> None: ...

        def modelStateChanged(self) -> None: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def registersUpdated(self, __a0: ghidra.dbg.target.TargetObject, __a1: java.util.Map) -> None: ...

        def removeChangeListener(self, __a0: ghidra.util.TriConsumer) -> None: ...

        def rootAdded(self, __a0: ghidra.dbg.target.TargetObject) -> None: ...

        def set(self, __a0: object, __a1: object) -> bool: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def waitChanged(self) -> java.util.concurrent.CompletableFuture: ...

        def waitUntil(self, __a0: java.util.function.Predicate) -> java.util.concurrent.CompletableFuture: ...

        def waitValue(self, __a0: object) -> java.util.concurrent.CompletableFuture: ...






    class AncestorTraversal(java.util.concurrent.CompletableFuture):




        def __init__(self, __a0: ghidra.dbg.target.TargetObject): ...



        def acceptEither(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Consumer) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def acceptEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Consumer) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def acceptEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Consumer, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        @staticmethod
        def allOf(__a0: List[java.util.concurrent.CompletableFuture]) -> java.util.concurrent.CompletableFuture: ...

        @staticmethod
        def anyOf(__a0: List[java.util.concurrent.CompletableFuture]) -> java.util.concurrent.CompletableFuture: ...

        def applyToEither(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def applyToEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def applyToEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.Function, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def cancel(self, __a0: bool) -> bool: ...

        def complete(self, __a0: object) -> bool: ...

        @overload
        def completeAsync(self, __a0: java.util.function.Supplier) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def completeAsync(self, __a0: java.util.function.Supplier, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def completeExceptionally(self, __a0: java.lang.Throwable) -> bool: ...

        def completeOnTimeout(self, __a0: object, __a1: long, __a2: java.util.concurrent.TimeUnit) -> java.util.concurrent.CompletableFuture: ...

        @staticmethod
        def completedFuture(__a0: object) -> java.util.concurrent.CompletableFuture: ...

        @staticmethod
        def completedStage(__a0: object) -> java.util.concurrent.CompletionStage: ...

        def copy(self) -> java.util.concurrent.CompletableFuture: ...

        def defaultExecutor(self) -> java.util.concurrent.Executor: ...

        @overload
        @staticmethod
        def delayedExecutor(__a0: long, __a1: java.util.concurrent.TimeUnit) -> java.util.concurrent.Executor: ...

        @overload
        @staticmethod
        def delayedExecutor(__a0: long, __a1: java.util.concurrent.TimeUnit, __a2: java.util.concurrent.Executor) -> java.util.concurrent.Executor: ...

        def equals(self, __a0: object) -> bool: ...

        def exceptionNow(self) -> java.lang.Throwable: ...

        def exceptionally(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def exceptionallyAsync(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def exceptionallyAsync(self, __a0: java.util.function.Function, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def exceptionallyCompose(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def exceptionallyComposeAsync(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def exceptionallyComposeAsync(self, __a0: java.util.function.Function, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        @staticmethod
        def failedFuture(__a0: java.lang.Throwable) -> java.util.concurrent.CompletableFuture: ...

        @staticmethod
        def failedStage(__a0: java.lang.Throwable) -> java.util.concurrent.CompletionStage: ...

        @overload
        def get(self) -> object: ...

        @overload
        def get(self, __a0: long, __a1: java.util.concurrent.TimeUnit) -> object: ...

        def getClass(self) -> java.lang.Class: ...

        def getNow(self, __a0: object) -> object: ...

        def getNumberOfDependents(self) -> int: ...

        def handle(self, __a0: java.util.function.BiFunction) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def handleAsync(self, __a0: java.util.function.BiFunction) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def handleAsync(self, __a0: java.util.function.BiFunction, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def hashCode(self) -> int: ...

        def isCancelled(self) -> bool: ...

        def isCompletedExceptionally(self) -> bool: ...

        def isDone(self) -> bool: ...

        def join(self) -> object: ...

        def minimalCompletionStage(self) -> java.util.concurrent.CompletionStage: ...

        def newIncompleteFuture(self) -> java.util.concurrent.CompletableFuture: ...

        def notify(self) -> None: ...

        def notifyAll(self) -> None: ...

        def obtrudeException(self, __a0: java.lang.Throwable) -> None: ...

        def obtrudeValue(self, __a0: object) -> None: ...

        def orTimeout(self, __a0: long, __a1: java.util.concurrent.TimeUnit) -> java.util.concurrent.CompletableFuture: ...

        def resultNow(self) -> object: ...

        def runAfterBoth(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable) -> java.util.concurrent.CompletionStage: ...

        @overload
        def runAfterBothAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable) -> java.util.concurrent.CompletionStage: ...

        @overload
        def runAfterBothAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def runAfterEither(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def runAfterEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def runAfterEitherAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.lang.Runnable, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        @overload
        @staticmethod
        def runAsync(__a0: java.lang.Runnable) -> java.util.concurrent.CompletableFuture: ...

        @overload
        @staticmethod
        def runAsync(__a0: java.lang.Runnable, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def start(self) -> ghidra.dbg.DebugModelConventions.AncestorTraversal: ...

        def state(self) -> java.util.concurrent.Future.State: ...

        @overload
        @staticmethod
        def supplyAsync(__a0: java.util.function.Supplier) -> java.util.concurrent.CompletableFuture: ...

        @overload
        @staticmethod
        def supplyAsync(__a0: java.util.function.Supplier, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def thenAccept(self, __a0: java.util.function.Consumer) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenAcceptAsync(self, __a0: java.util.function.Consumer) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenAcceptAsync(self, __a0: java.util.function.Consumer, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def thenAcceptBoth(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiConsumer) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def thenAcceptBothAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiConsumer) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenAcceptBothAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiConsumer, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def thenApply(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenApplyAsync(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenApplyAsync(self, __a0: java.util.function.Function, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def thenCombine(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiFunction) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def thenCombineAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiFunction) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenCombineAsync(self, __a0: java.util.concurrent.CompletionStage, __a1: java.util.function.BiFunction, __a2: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def thenCompose(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def thenComposeAsync(self, __a0: java.util.function.Function) -> java.util.concurrent.CompletionStage: ...

        @overload
        def thenComposeAsync(self, __a0: java.util.function.Function, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletionStage: ...

        def thenRun(self, __a0: java.lang.Runnable) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def thenRunAsync(self, __a0: java.lang.Runnable) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def thenRunAsync(self, __a0: java.lang.Runnable, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...

        def toCompletableFuture(self) -> java.util.concurrent.CompletableFuture: ...

        def toString(self) -> unicode: ...

        @overload
        def wait(self) -> None: ...

        @overload
        def wait(self, __a0: long) -> None: ...

        @overload
        def wait(self, __a0: long, __a1: int) -> None: ...

        def whenComplete(self, __a0: java.util.function.BiConsumer) -> java.util.concurrent.CompletionStage: ...

        @overload
        def whenCompleteAsync(self, __a0: java.util.function.BiConsumer) -> java.util.concurrent.CompletableFuture: ...

        @overload
        def whenCompleteAsync(self, __a0: java.util.function.BiConsumer, __a1: java.util.concurrent.Executor) -> java.util.concurrent.CompletableFuture: ...







    @staticmethod
    def ancestor(__a0: java.lang.Class, __a1: ghidra.dbg.target.TargetObject) -> ghidra.dbg.target.TargetObject: ...

    @staticmethod
    def collectAncestors(__a0: ghidra.dbg.target.TargetObject, __a1: java.lang.Class) -> java.util.concurrent.CompletableFuture: ...

    @staticmethod
    def collectSuccessors(__a0: ghidra.dbg.target.TargetObject, __a1: java.lang.Class) -> java.util.concurrent.CompletableFuture: ...

    @overload
    def compareTo(self, __a0: java.lang.Enum) -> int: ...

    @overload
    def compareTo(self, __a0: object) -> int: ...

    def describeConstable(self) -> java.util.Optional: ...

    def equals(self, __a0: object) -> bool: ...

    @overload
    @staticmethod
    def findInAggregate(__a0: java.lang.Class, __a1: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    @overload
    @staticmethod
    def findInAggregate(__a0: java.lang.Class, __a1: java.util.Collection) -> java.util.concurrent.CompletableFuture: ...

    @staticmethod
    def findSuitable(__a0: java.lang.Class, __a1: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    @staticmethod
    def findThread(__a0: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    def getClass(self) -> java.lang.Class: ...

    def getDeclaringClass(self) -> java.lang.Class: ...

    def hashCode(self) -> int: ...

    @staticmethod
    def isProcessAlive(__a0: ghidra.dbg.target.TargetProcess) -> bool: ...

    @staticmethod
    def liveProcessOrNull(__a0: ghidra.dbg.target.TargetObject) -> ghidra.dbg.target.TargetProcess: ...

    def name(self) -> unicode: ...

    @staticmethod
    def nearestAncestor(__a0: java.lang.Class, __a1: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def ordinal(self) -> int: ...

    @staticmethod
    def requestActivation(__a0: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    @staticmethod
    def requestFocus(__a0: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    @staticmethod
    def suitable(__a0: java.lang.Class, __a1: ghidra.dbg.target.TargetObject) -> java.util.concurrent.CompletableFuture: ...

    def toString(self) -> unicode: ...

    @overload
    @staticmethod
    def valueOf(__a0: unicode) -> ghidra.dbg.DebugModelConventions: ...

    @overload
    @staticmethod
    def valueOf(__a0: java.lang.Class, __a1: unicode) -> java.lang.Enum: ...

    @staticmethod
    def values() -> List[ghidra.dbg.DebugModelConventions]: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

