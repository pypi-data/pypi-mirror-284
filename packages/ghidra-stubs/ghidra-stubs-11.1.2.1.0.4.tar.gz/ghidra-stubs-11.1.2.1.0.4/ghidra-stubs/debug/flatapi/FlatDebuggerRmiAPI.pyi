from typing import List
from typing import overload
import docking
import ghidra.app.script
import ghidra.app.services
import ghidra.dbg.target
import ghidra.debug.api.control
import ghidra.debug.api.target
import ghidra.debug.api.tracemgr
import ghidra.debug.api.tracermi
import ghidra.debug.flatapi
import ghidra.program.model.address
import ghidra.program.model.lang
import ghidra.program.model.listing
import ghidra.program.util
import ghidra.trace.model
import ghidra.trace.model.breakpoint
import ghidra.trace.model.guest
import ghidra.trace.model.program
import ghidra.trace.model.target
import ghidra.trace.model.thread
import ghidra.trace.model.time.schedule
import ghidra.util.task
import java.lang
import java.nio
import java.util
import java.util.concurrent


class FlatDebuggerRmiAPI(ghidra.debug.flatapi.FlatDebuggerAPI, object):








    def activateFrame(self, __a0: int) -> None: ...

    def activateSnap(self, __a0: long) -> None: ...

    def activateThread(self, __a0: ghidra.trace.model.thread.TraceThread) -> None: ...

    def activateTrace(self, __a0: ghidra.trace.model.Trace) -> None: ...

    def breakpointSet(self, __a0: ghidra.program.util.ProgramLocation, __a1: long, __a2: ghidra.trace.model.breakpoint.TraceBreakpointKind.TraceBreakpointKindSet, __a3: unicode) -> java.util.Set: ...

    def breakpointSetAccess(self, __a0: ghidra.program.util.ProgramLocation, __a1: int, __a2: unicode) -> java.util.Set: ...

    def breakpointSetHardwareExecute(self, __a0: ghidra.program.util.ProgramLocation, __a1: unicode) -> java.util.Set: ...

    def breakpointSetRead(self, __a0: ghidra.program.util.ProgramLocation, __a1: int, __a2: unicode) -> java.util.Set: ...

    def breakpointSetSoftwareExecute(self, __a0: ghidra.program.util.ProgramLocation, __a1: unicode) -> java.util.Set: ...

    def breakpointSetWrite(self, __a0: ghidra.program.util.ProgramLocation, __a1: int, __a2: unicode) -> java.util.Set: ...

    def breakpointsClear(self, __a0: ghidra.program.util.ProgramLocation) -> bool: ...

    def breakpointsDisable(self, __a0: ghidra.program.util.ProgramLocation) -> java.util.Set: ...

    def breakpointsEnable(self, __a0: ghidra.program.util.ProgramLocation) -> java.util.Set: ...

    def breakpointsToggle(self, __a0: ghidra.program.util.ProgramLocation) -> java.util.Set: ...

    def closeTrace(self, __a0: ghidra.trace.model.Trace) -> None: ...

    @overload
    def createContext(self, __a0: ghidra.trace.model.Trace) -> docking.ActionContext: ...

    @overload
    def createContext(self, __a0: ghidra.trace.model.target.TraceObject) -> docking.ActionContext: ...

    @overload
    def createContext(self, __a0: ghidra.trace.model.thread.TraceThread) -> docking.ActionContext: ...

    @overload
    def createStateEditor(self) -> ghidra.app.services.DebuggerControlService.StateEditor: ...

    @overload
    def createStateEditor(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates) -> ghidra.app.services.DebuggerControlService.StateEditor: ...

    @overload
    def createStateEditor(self, __a0: ghidra.trace.model.Trace, __a1: long) -> ghidra.app.services.DebuggerControlService.StateEditor: ...

    @overload
    def createStateEditor(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: long) -> ghidra.app.services.DebuggerControlService.StateEditor: ...

    def doAction(self, __a0: ghidra.debug.api.target.Target, __a1: ghidra.debug.api.target.ActionName, __a2: docking.ActionContext) -> object: ...

    def doThreadAction(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: ghidra.debug.api.target.ActionName) -> bool: ...

    def doTraceAction(self, __a0: ghidra.trace.model.Trace, __a1: ghidra.debug.api.target.ActionName) -> bool: ...

    @overload
    def dynamicLocation(self, __a0: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.Trace, __a1: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.program.TraceProgramView, __a1: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.Trace, __a1: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.program.TraceProgramView, __a1: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def dynamicLocation(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def emulate(self, __a0: ghidra.trace.model.time.schedule.TraceSchedule, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def emulate(self, __a0: ghidra.trace.model.Trace, __a1: ghidra.trace.model.time.schedule.TraceSchedule, __a2: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def emulate(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.time.schedule.TraceSchedule, __a2: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def emulateLaunch(self, __a0: ghidra.program.model.address.Address) -> ghidra.trace.model.Trace: ...

    @overload
    def emulateLaunch(self, __a0: ghidra.program.model.listing.Program, __a1: ghidra.program.model.address.Address) -> ghidra.trace.model.Trace: ...

    def equals(self, __a0: object) -> bool: ...

    @overload
    def evaluate(self, __a0: unicode) -> long: ...

    @overload
    def evaluate(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates, __a1: unicode) -> long: ...

    @overload
    def execute(self, __a0: unicode) -> bool: ...

    @overload
    def execute(self, __a0: ghidra.trace.model.Trace, __a1: unicode) -> bool: ...

    @overload
    def executeCapture(self, __a0: unicode) -> unicode: ...

    @overload
    def executeCapture(self, __a0: ghidra.trace.model.Trace, __a1: unicode) -> unicode: ...

    def expectBreakpointChanges(self) -> ghidra.debug.flatapi.FlatDebuggerAPI.ExpectingBreakpointChanges: ...

    def findAction(self, __a0: ghidra.debug.api.target.Target, __a1: ghidra.debug.api.target.ActionName, __a2: docking.ActionContext) -> ghidra.debug.api.target.Target.ActionEntry: ...

    def flushAsyncPipelines(self, __a0: ghidra.trace.model.Trace) -> bool: ...

    def getAllBreakpoints(self) -> java.util.Set: ...

    def getBreakpointService(self) -> ghidra.app.services.DebuggerLogicalBreakpointService: ...

    @overload
    def getBreakpoints(self, __a0: ghidra.program.model.listing.Program) -> java.util.NavigableMap: ...

    @overload
    def getBreakpoints(self, __a0: ghidra.trace.model.Trace) -> java.util.NavigableMap: ...

    def getBreakpointsAt(self, __a0: ghidra.program.util.ProgramLocation) -> java.util.Set: ...

    def getBreakpointsNamed(self, __a0: unicode) -> java.util.Set: ...

    def getClass(self) -> java.lang.Class: ...

    def getControlService(self) -> ghidra.app.services.DebuggerControlService: ...

    def getCurrentDebuggerAddress(self) -> ghidra.program.model.address.Address: ...

    def getCurrentDebuggerCoordinates(self) -> ghidra.debug.api.tracemgr.DebuggerCoordinates: ...

    def getCurrentDebuggerProgramLocation(self) -> ghidra.program.util.ProgramLocation: ...

    def getCurrentEmulationSchedule(self) -> ghidra.trace.model.time.schedule.TraceSchedule: ...

    def getCurrentFrame(self) -> int: ...

    def getCurrentPlatform(self) -> ghidra.trace.model.guest.TracePlatform: ...

    def getCurrentProgram(self) -> ghidra.program.model.listing.Program: ...

    def getCurrentSnap(self) -> long: ...

    def getCurrentThread(self) -> ghidra.trace.model.thread.TraceThread: ...

    def getCurrentTrace(self) -> ghidra.trace.model.Trace: ...

    def getCurrentView(self) -> ghidra.trace.model.program.TraceProgramView: ...

    def getDebuggerListing(self) -> ghidra.app.services.DebuggerListingService: ...

    def getEmulationService(self) -> ghidra.app.services.DebuggerEmulationService: ...

    @overload
    def getExecutionState(self, __a0: ghidra.trace.model.Trace) -> ghidra.dbg.target.TargetExecutionStateful.TargetExecutionState: ...

    @overload
    def getExecutionState(self, __a0: ghidra.trace.model.thread.TraceThread) -> ghidra.dbg.target.TargetExecutionStateful.TargetExecutionState: ...

    @overload
    def getLaunchOffers(self) -> java.util.Collection: ...

    @overload
    def getLaunchOffers(self, __a0: ghidra.program.model.listing.Program) -> java.util.Collection: ...

    def getMappingService(self) -> ghidra.app.services.DebuggerStaticMappingService: ...

    @overload
    def getProgramCounter(self) -> ghidra.program.model.address.Address: ...

    @overload
    def getProgramCounter(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates) -> ghidra.program.model.address.Address: ...

    @overload
    def getSavedLaunchOffers(self) -> List[object]: ...

    @overload
    def getSavedLaunchOffers(self, __a0: ghidra.program.model.listing.Program) -> List[object]: ...

    @overload
    def getStackPointer(self) -> ghidra.program.model.address.Address: ...

    @overload
    def getStackPointer(self, __a0: ghidra.debug.api.tracemgr.DebuggerCoordinates) -> ghidra.program.model.address.Address: ...

    def getState(self) -> ghidra.app.script.GhidraState: ...

    def getTargetService(self) -> ghidra.app.services.DebuggerTargetService: ...

    def getTrace(self, __a0: ghidra.program.util.ProgramLocation) -> ghidra.trace.model.Trace: ...

    def getTraceManager(self) -> ghidra.app.services.DebuggerTraceManagerService: ...

    def getTraceRmiLauncherService(self) -> ghidra.app.services.TraceRmiLauncherService: ...

    @overload
    def goToDynamic(self, __a0: unicode) -> bool: ...

    @overload
    def goToDynamic(self, __a0: ghidra.program.model.address.Address) -> bool: ...

    @overload
    def goToDynamic(self, __a0: ghidra.program.util.ProgramLocation) -> bool: ...

    def hashCode(self) -> int: ...

    @overload
    def interrupt(self) -> bool: ...

    @overload
    def interrupt(self, __a0: ghidra.trace.model.Trace) -> bool: ...

    @overload
    def interrupt(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    @overload
    def isTargetAlive(self) -> bool: ...

    @overload
    def isTargetAlive(self, __a0: ghidra.trace.model.Trace) -> bool: ...

    @overload
    def isThreadAlive(self) -> bool: ...

    @overload
    def isThreadAlive(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    @overload
    def kill(self) -> bool: ...

    @overload
    def kill(self, __a0: ghidra.trace.model.Trace) -> bool: ...

    @overload
    def kill(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    @overload
    def launch(self, __a0: ghidra.util.task.TaskMonitor) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer.LaunchResult: ...

    @overload
    def launch(self, __a0: ghidra.debug.api.tracermi.TraceRmiLaunchOffer, __a1: ghidra.util.task.TaskMonitor) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer.LaunchResult: ...

    @overload
    def launch(self, __a0: ghidra.program.model.listing.Program, __a1: ghidra.util.task.TaskMonitor) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer.LaunchResult: ...

    @overload
    def launch(self, __a0: ghidra.debug.api.tracermi.TraceRmiLaunchOffer, __a1: java.util.Map, __a2: ghidra.util.task.TaskMonitor) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer.LaunchResult: ...

    def notify(self) -> None: ...

    def notifyAll(self) -> None: ...

    def openTrace(self, __a0: ghidra.trace.model.Trace) -> None: ...

    def patchEmu(self, __a0: unicode, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def readMemory(self, __a0: ghidra.program.model.address.Address, __a1: int, __a2: ghidra.util.task.TaskMonitor) -> List[int]: ...

    @overload
    def readMemory(self, __a0: ghidra.program.model.address.Address, __a1: List[int], __a2: ghidra.util.task.TaskMonitor) -> int: ...

    @overload
    def readMemory(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.Address, __a3: int, __a4: ghidra.util.task.TaskMonitor) -> List[int]: ...

    @overload
    def readMemory(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.Address, __a3: List[int], __a4: ghidra.util.task.TaskMonitor) -> int: ...

    @overload
    def readRegister(self, __a0: unicode) -> ghidra.program.model.lang.RegisterValue: ...

    @overload
    def readRegister(self, __a0: ghidra.program.model.lang.Register) -> ghidra.program.model.lang.RegisterValue: ...

    @overload
    def readRegister(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.program.model.lang.Register) -> ghidra.program.model.lang.RegisterValue: ...

    @overload
    def readRegister(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: long, __a4: ghidra.program.model.lang.Register) -> ghidra.program.model.lang.RegisterValue: ...

    @overload
    def readRegisters(self, __a0: java.util.Collection) -> List[object]: ...

    @overload
    def readRegisters(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: long, __a4: java.util.Collection) -> List[object]: ...

    def readRegistersNamed(self, __a0: java.util.Collection) -> List[object]: ...

    def refreshMemoryIfLive(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.Address, __a3: int, __a4: ghidra.util.task.TaskMonitor) -> None: ...

    def refreshRegistersIfLive(self, __a0: ghidra.trace.model.guest.TracePlatform, __a1: ghidra.trace.model.thread.TraceThread, __a2: int, __a3: long, __a4: java.util.Collection) -> None: ...

    def requireCurrentPlatform(self) -> ghidra.trace.model.guest.TracePlatform: ...

    def requireCurrentProgram(self) -> ghidra.program.model.listing.Program: ...

    def requireCurrentThread(self) -> ghidra.trace.model.thread.TraceThread: ...

    def requireCurrentTrace(self) -> ghidra.trace.model.Trace: ...

    def requireCurrentView(self) -> ghidra.trace.model.program.TraceProgramView: ...

    @overload
    def requireLastLaunchOffer(self) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer: ...

    @overload
    def requireLastLaunchOffer(self, __a0: ghidra.program.model.listing.Program) -> ghidra.debug.api.tracermi.TraceRmiLaunchOffer: ...

    def requirePlatform(self, __a0: ghidra.trace.model.guest.TracePlatform) -> ghidra.trace.model.guest.TracePlatform: ...

    def requireService(self, __a0: java.lang.Class) -> object: ...

    def requireThread(self, __a0: ghidra.trace.model.thread.TraceThread) -> ghidra.trace.model.thread.TraceThread: ...

    def requireTrace(self, __a0: ghidra.trace.model.Trace) -> ghidra.trace.model.Trace: ...

    @overload
    def resume(self) -> bool: ...

    @overload
    def resume(self, __a0: ghidra.trace.model.Trace) -> bool: ...

    @overload
    def resume(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    def safeRange(self, __a0: ghidra.program.model.address.Address, __a1: int) -> ghidra.program.model.address.AddressRange: ...

    @overload
    def searchMemory(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.AddressRange, __a3: List[int], __a4: List[int], __a5: bool, __a6: ghidra.util.task.TaskMonitor) -> ghidra.program.model.address.Address: ...

    @overload
    def searchMemory(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.AddressRange, __a3: java.nio.ByteBuffer, __a4: java.nio.ByteBuffer, __a5: bool, __a6: ghidra.util.task.TaskMonitor) -> ghidra.program.model.address.Address: ...

    @overload
    def setControlMode(self, __a0: ghidra.debug.api.control.ControlMode) -> None: ...

    @overload
    def setControlMode(self, __a0: ghidra.trace.model.Trace, __a1: ghidra.debug.api.control.ControlMode) -> None: ...

    def skipEmuInstruction(self, __a0: long, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    def skipEmuPcodeOp(self, __a0: int, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def staticLocation(self, __a0: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def staticLocation(self, __a0: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def staticLocation(self, __a0: ghidra.program.model.listing.Program, __a1: unicode) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def staticLocation(self, __a0: ghidra.program.model.listing.Program, __a1: ghidra.program.model.address.Address) -> ghidra.program.util.ProgramLocation: ...

    def stepEmuInstruction(self, __a0: long, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    def stepEmuPcodeOp(self, __a0: int, __a1: ghidra.util.task.TaskMonitor) -> bool: ...

    @overload
    def stepInto(self) -> bool: ...

    @overload
    def stepInto(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    @overload
    def stepOut(self) -> bool: ...

    @overload
    def stepOut(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    @overload
    def stepOver(self) -> bool: ...

    @overload
    def stepOver(self, __a0: ghidra.trace.model.thread.TraceThread) -> bool: ...

    def toString(self) -> unicode: ...

    @overload
    def translateDynamicToStatic(self, __a0: ghidra.program.model.address.Address) -> ghidra.program.model.address.Address: ...

    @overload
    def translateDynamicToStatic(self, __a0: ghidra.program.util.ProgramLocation) -> ghidra.program.util.ProgramLocation: ...

    @overload
    def translateStaticToDynamic(self, __a0: ghidra.program.model.address.Address) -> ghidra.program.model.address.Address: ...

    @overload
    def translateStaticToDynamic(self, __a0: ghidra.program.util.ProgramLocation) -> ghidra.program.util.ProgramLocation: ...

    def validateRegisterName(self, __a0: ghidra.program.model.lang.Language, __a1: unicode) -> ghidra.program.model.lang.Register: ...

    def validateRegisterNames(self, __a0: ghidra.program.model.lang.Language, __a1: java.util.Collection) -> List[object]: ...

    @overload
    def wait(self) -> None: ...

    @overload
    def wait(self, __a0: long) -> None: ...

    @overload
    def wait(self, __a0: long, __a1: int) -> None: ...

    @overload
    def waitForBreak(self, __a0: long, __a1: java.util.concurrent.TimeUnit) -> None: ...

    @overload
    def waitForBreak(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: java.util.concurrent.TimeUnit) -> None: ...

    def waitOn(self, __a0: java.util.concurrent.CompletableFuture) -> object: ...

    @overload
    def writeMemory(self, __a0: ghidra.program.model.address.Address, __a1: List[int]) -> bool: ...

    @overload
    def writeMemory(self, __a0: ghidra.app.services.DebuggerControlService.StateEditor, __a1: ghidra.program.model.address.Address, __a2: List[int]) -> bool: ...

    @overload
    def writeMemory(self, __a0: ghidra.trace.model.Trace, __a1: long, __a2: ghidra.program.model.address.Address, __a3: List[int]) -> bool: ...

    @overload
    def writeRegister(self, __a0: ghidra.program.model.lang.RegisterValue) -> bool: ...

    @overload
    def writeRegister(self, __a0: unicode, __a1: long) -> bool: ...

    @overload
    def writeRegister(self, __a0: ghidra.app.services.DebuggerControlService.StateEditor, __a1: ghidra.program.model.lang.RegisterValue) -> bool: ...

    @overload
    def writeRegister(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: long, __a3: ghidra.program.model.lang.RegisterValue) -> bool: ...

    @overload
    def writeRegister(self, __a0: ghidra.trace.model.thread.TraceThread, __a1: int, __a2: long, __a3: unicode, __a4: long) -> bool: ...

    @property
    def allBreakpoints(self) -> java.util.Set: ...

    @property
    def breakpointService(self) -> ghidra.app.services.DebuggerLogicalBreakpointService: ...

    @property
    def controlMode(self) -> None: ...  # No getter available.

    @controlMode.setter
    def controlMode(self, value: ghidra.debug.api.control.ControlMode) -> None: ...

    @property
    def controlService(self) -> ghidra.app.services.DebuggerControlService: ...

    @property
    def currentDebuggerAddress(self) -> ghidra.program.model.address.Address: ...

    @property
    def currentDebuggerCoordinates(self) -> ghidra.debug.api.tracemgr.DebuggerCoordinates: ...

    @property
    def currentDebuggerProgramLocation(self) -> ghidra.program.util.ProgramLocation: ...

    @property
    def currentEmulationSchedule(self) -> ghidra.trace.model.time.schedule.TraceSchedule: ...

    @property
    def currentFrame(self) -> int: ...

    @property
    def currentPlatform(self) -> ghidra.trace.model.guest.TracePlatform: ...

    @property
    def currentProgram(self) -> ghidra.program.model.listing.Program: ...

    @property
    def currentSnap(self) -> long: ...

    @property
    def currentThread(self) -> ghidra.trace.model.thread.TraceThread: ...

    @property
    def currentTrace(self) -> ghidra.trace.model.Trace: ...

    @property
    def currentView(self) -> ghidra.trace.model.program.TraceProgramView: ...

    @property
    def debuggerListing(self) -> ghidra.app.services.DebuggerListingService: ...

    @property
    def emulationService(self) -> ghidra.app.services.DebuggerEmulationService: ...

    @property
    def launchOffers(self) -> java.util.Collection: ...

    @property
    def mappingService(self) -> ghidra.app.services.DebuggerStaticMappingService: ...

    @property
    def programCounter(self) -> ghidra.program.model.address.Address: ...

    @property
    def savedLaunchOffers(self) -> List[object]: ...

    @property
    def stackPointer(self) -> ghidra.program.model.address.Address: ...

    @property
    def state(self) -> ghidra.app.script.GhidraState: ...

    @property
    def targetAlive(self) -> bool: ...

    @property
    def targetService(self) -> ghidra.app.services.DebuggerTargetService: ...

    @property
    def threadAlive(self) -> bool: ...

    @property
    def traceManager(self) -> ghidra.app.services.DebuggerTraceManagerService: ...

    @property
    def traceRmiLauncherService(self) -> ghidra.app.services.TraceRmiLauncherService: ...