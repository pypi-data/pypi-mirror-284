# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.billing_reason_enum import BillingReasonEnum
from ..types.collection_method_enum import CollectionMethodEnum
from ..types.date_time_filter import DateTimeFilter
from ..types.http_validation_error import HttpValidationError
from ..types.int_range_filter import IntRangeFilter
from ..types.invoice_external import InvoiceExternal
from ..types.invoice_public import InvoicePublic
from ..types.invoice_status_enum import InvoiceStatusEnum
from ..types.list_response_invoice_external import ListResponseInvoiceExternal
from .types.discounts import Discounts

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class InvoicesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        status: typing.Optional[InvoiceStatusEnum] = OMIT,
        subscription_id: typing.Optional[str] = OMIT,
        billing_reason: typing.Optional[BillingReasonEnum] = OMIT,
        total_amount_atom: typing.Optional[IntRangeFilter] = OMIT,
        period_start: typing.Optional[DateTimeFilter] = OMIT,
        period_end: typing.Optional[DateTimeFilter] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[InvoiceExternal]:
        """
        Parameters
        ----------
        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        customer_id : typing.Optional[str]
            Unique identifier of the customer.

        status : typing.Optional[InvoiceStatusEnum]
            Status of invoice.

        subscription_id : typing.Optional[str]
            Unique identifier of the subscription.

        billing_reason : typing.Optional[BillingReasonEnum]
            Indicates the reason why the invoice was created.

        total_amount_atom : typing.Optional[IntRangeFilter]
            This contains fields used for range filters on total_amount_atom field.

        period_start : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period starting dates. Includes options for equality, and greater than/less than comparisons.

        period_end : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period ending dates. Includes options for equality, and greater than/less than comparisons.

        coupon_id : typing.Optional[str]
            Coupon id which is applied to an invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[InvoiceExternal]
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        response = client.invoices.list()
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        page_number = page_number if page_number is not None else 1
        _response = self._client_wrapper.httpx_client.request(
            "invoices/list",
            method="POST",
            json={
                "page_number": page_number,
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "customer_id": customer_id,
                "status": status,
                "subscription_id": subscription_id,
                "billing_reason": billing_reason,
                "total_amount_atom": total_amount_atom,
                "period_start": period_start,
                "period_end": period_end,
                "coupon_id": coupon_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page_number=page_number + 1,
                    page_size=page_size,
                    sort_key=sort_key,
                    sort_descending=sort_descending,
                    created_at=created_at,
                    expand=expand,
                    customer_id=customer_id,
                    status=status,
                    subscription_id=subscription_id,
                    billing_reason=billing_reason,
                    total_amount_atom=total_amount_atom,
                    period_start=period_start,
                    period_end=period_end,
                    coupon_id=coupon_id,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.get(
            invoice_external_id="invoice_external_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_public_invoice(
        self, public_permanent_token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoicePublic:
        """
        Parameters
        ----------
        public_permanent_token : str
            Public token for the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoicePublic
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.get_public_invoice(
            public_permanent_token="public_permanent_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/public/{jsonable_encoder(public_permanent_token)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoicePublic, construct_type(type_=InvoicePublic, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        subscription_id: str,
        payment_method_id: typing.Optional[str] = OMIT,
        collection_method: typing.Optional[CollectionMethodEnum] = OMIT,
        description: typing.Optional[str] = OMIT,
        discounts: typing.Optional[Discounts] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        This endpoint creates a draft invoice for a given subscription.
        The invoice remains a draft until you finalize the invoice.
        The created invoice will only include floating invoice items for a subscription.
        The subscription’s billing cycle and regular subscription events won’t be affected.

        Parameters
        ----------
        subscription_id : str
            Unique identifier of the subscription. The created invoice will only include pending invoice items for that subscription. The subscription’s billing cycle and regular subscription events won’t be affected.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        collection_method : typing.Optional[CollectionMethodEnum]
            When charging automatically, We will attempt to pay this invoice using the default source attached to the customer. Defaults to charge_automatically.

        description : typing.Optional[str]
            Description for newly created invoice

        discounts : typing.Optional[Discounts]
            The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from one of its ancestors. Pass 'null' to not apply any discounts to this invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.create(
            subscription_id="subscription_dev_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "invoices/",
            method="POST",
            json={
                "subscription_id": subscription_id,
                "payment_method_id": payment_method_id,
                "collection_method": collection_method,
                "description": description,
                "discounts": discounts,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def finalize(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.finalize(
            invoice_external_id="invoice_external_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/finalize", method="POST", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def pay(
        self,
        invoice_external_id: str,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        paid_out_of_band: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        paid_out_of_band : typing.Optional[bool]
            Boolean representing whether an invoice is paid outside of OpenPay. This will result in no charge being made. Defaults to false.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.pay(
            invoice_external_id="invoice_external_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/pay",
            method="POST",
            json={"payment_method_id": payment_method_id, "paid_out_of_band": paid_out_of_band},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def mark_as_uncollectible(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.mark_as_uncollectible(
            invoice_external_id="invoice_external_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/mark_uncollectible",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def mark_as_void(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.mark_as_void(
            invoice_external_id="invoice_external_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/void", method="POST", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        invoice_id: str,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        discounts: typing.Optional[Discounts] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_id : str
            Unique identifier of the invoice.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        description : typing.Optional[str]
            Description for newly created invoice

        discounts : typing.Optional[Discounts]
            The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from one of its ancestors. Pass 'null' to not apply any discounts to this invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.update(
            invoice_id="invoice_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_id)}",
            method="PUT",
            json={"payment_method_id": payment_method_id, "description": description, "discounts": discounts},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search(
        self,
        *,
        query: str,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListResponseInvoiceExternal:
        """
        Parameters
        ----------
        query : str
            The search query string in limited Lucene Query Syntax. Query is case insensitive.
                Limitations:
                  1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.
                  2. Nesting of Queries by ( ) is not supported.
                Example searches.
                  1. search by exact field. example: `name:'field_name'`
                  2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`
                  3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.


        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseInvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.invoices.search(
            query="query",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "invoices/search",
            method="POST",
            json={"page_number": page_number, "page_size": page_size, "query": query},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncInvoicesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        status: typing.Optional[InvoiceStatusEnum] = OMIT,
        subscription_id: typing.Optional[str] = OMIT,
        billing_reason: typing.Optional[BillingReasonEnum] = OMIT,
        total_amount_atom: typing.Optional[IntRangeFilter] = OMIT,
        period_start: typing.Optional[DateTimeFilter] = OMIT,
        period_end: typing.Optional[DateTimeFilter] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[InvoiceExternal]:
        """
        Parameters
        ----------
        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        customer_id : typing.Optional[str]
            Unique identifier of the customer.

        status : typing.Optional[InvoiceStatusEnum]
            Status of invoice.

        subscription_id : typing.Optional[str]
            Unique identifier of the subscription.

        billing_reason : typing.Optional[BillingReasonEnum]
            Indicates the reason why the invoice was created.

        total_amount_atom : typing.Optional[IntRangeFilter]
            This contains fields used for range filters on total_amount_atom field.

        period_start : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period starting dates. Includes options for equality, and greater than/less than comparisons.

        period_end : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period ending dates. Includes options for equality, and greater than/less than comparisons.

        coupon_id : typing.Optional[str]
            Coupon id which is applied to an invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[InvoiceExternal]
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            response = await client.invoices.list()
            async for item in response:
                yield item
            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page


        asyncio.run(main())
        """
        page_number = page_number if page_number is not None else 1
        _response = await self._client_wrapper.httpx_client.request(
            "invoices/list",
            method="POST",
            json={
                "page_number": page_number,
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "customer_id": customer_id,
                "status": status,
                "subscription_id": subscription_id,
                "billing_reason": billing_reason,
                "total_amount_atom": total_amount_atom,
                "period_start": period_start,
                "period_end": period_end,
                "coupon_id": coupon_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page_number=page_number + 1,
                    page_size=page_size,
                    sort_key=sort_key,
                    sort_descending=sort_descending,
                    created_at=created_at,
                    expand=expand,
                    customer_id=customer_id,
                    status=status,
                    subscription_id=subscription_id,
                    billing_reason=billing_reason,
                    total_amount_atom=total_amount_atom,
                    period_start=period_start,
                    period_end=period_end,
                    coupon_id=coupon_id,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.get(
                invoice_external_id="invoice_external_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_public_invoice(
        self, public_permanent_token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoicePublic:
        """
        Parameters
        ----------
        public_permanent_token : str
            Public token for the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoicePublic
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.get_public_invoice(
                public_permanent_token="public_permanent_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/public/{jsonable_encoder(public_permanent_token)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoicePublic, construct_type(type_=InvoicePublic, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        subscription_id: str,
        payment_method_id: typing.Optional[str] = OMIT,
        collection_method: typing.Optional[CollectionMethodEnum] = OMIT,
        description: typing.Optional[str] = OMIT,
        discounts: typing.Optional[Discounts] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        This endpoint creates a draft invoice for a given subscription.
        The invoice remains a draft until you finalize the invoice.
        The created invoice will only include floating invoice items for a subscription.
        The subscription’s billing cycle and regular subscription events won’t be affected.

        Parameters
        ----------
        subscription_id : str
            Unique identifier of the subscription. The created invoice will only include pending invoice items for that subscription. The subscription’s billing cycle and regular subscription events won’t be affected.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        collection_method : typing.Optional[CollectionMethodEnum]
            When charging automatically, We will attempt to pay this invoice using the default source attached to the customer. Defaults to charge_automatically.

        description : typing.Optional[str]
            Description for newly created invoice

        discounts : typing.Optional[Discounts]
            The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from one of its ancestors. Pass 'null' to not apply any discounts to this invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.create(
                subscription_id="subscription_dev_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "invoices/",
            method="POST",
            json={
                "subscription_id": subscription_id,
                "payment_method_id": payment_method_id,
                "collection_method": collection_method,
                "description": description,
                "discounts": discounts,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def finalize(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.finalize(
                invoice_external_id="invoice_external_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/finalize", method="POST", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def pay(
        self,
        invoice_external_id: str,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        paid_out_of_band: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        paid_out_of_band : typing.Optional[bool]
            Boolean representing whether an invoice is paid outside of OpenPay. This will result in no charge being made. Defaults to false.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.pay(
                invoice_external_id="invoice_external_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/pay",
            method="POST",
            json={"payment_method_id": payment_method_id, "paid_out_of_band": paid_out_of_band},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def mark_as_uncollectible(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.mark_as_uncollectible(
                invoice_external_id="invoice_external_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/mark_uncollectible",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def mark_as_void(
        self, invoice_external_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_external_id : str
            Unique identifier of the invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.mark_as_void(
                invoice_external_id="invoice_external_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_external_id)}/void", method="POST", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        invoice_id: str,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        discounts: typing.Optional[Discounts] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> InvoiceExternal:
        """
        Parameters
        ----------
        invoice_id : str
            Unique identifier of the invoice.

        payment_method_id : typing.Optional[str]
            Unique identifier of the payment method.

        description : typing.Optional[str]
            Description for newly created invoice

        discounts : typing.Optional[Discounts]
            The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from one of its ancestors. Pass 'null' to not apply any discounts to this invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        InvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.update(
                invoice_id="invoice_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"invoices/{jsonable_encoder(invoice_id)}",
            method="PUT",
            json={"payment_method_id": payment_method_id, "description": description, "discounts": discounts},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(InvoiceExternal, construct_type(type_=InvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search(
        self,
        *,
        query: str,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListResponseInvoiceExternal:
        """
        Parameters
        ----------
        query : str
            The search query string in limited Lucene Query Syntax. Query is case insensitive.
                Limitations:
                  1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.
                  2. Nesting of Queries by ( ) is not supported.
                Example searches.
                  1. search by exact field. example: `name:'field_name'`
                  2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`
                  3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.


        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseInvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.invoices.search(
                query="query",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "invoices/search",
            method="POST",
            json={"page_number": page_number, "page_size": page_size, "query": query},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
