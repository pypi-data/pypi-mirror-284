# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.billing_reason_enum import BillingReasonEnum
from ..types.billing_summary_external import BillingSummaryExternal
from ..types.date_time_filter import DateTimeFilter
from ..types.delete_subscription_request import DeleteSubscriptionRequest
from ..types.http_validation_error import HttpValidationError
from ..types.inline_subscription_item_update import InlineSubscriptionItemUpdate
from ..types.int_range_filter import IntRangeFilter
from ..types.invoice_status_enum import InvoiceStatusEnum
from ..types.list_response_invoice_external import ListResponseInvoiceExternal
from ..types.payment_method_external import PaymentMethodExternal
from ..types.portal_session_external import PortalSessionExternal
from ..types.prices_for_subscription_response import PricesForSubscriptionResponse
from ..types.proration_enum import ProrationEnum
from ..types.subscription_external import SubscriptionExternal
from ..types.update_mode import UpdateMode
from ..types.update_subscription_public_response import UpdateSubscriptionPublicResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class BillingPortalClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_session(
        self, *, customer_id: str, return_url: str, request_options: typing.Optional[RequestOptions] = None
    ) -> PortalSessionExternal:
        """
        Parameters
        ----------
        customer_id : str
            The ID of an existing customer.

        return_url : str
            The default URL to redirect customers to when they click on the portal's link to return to your website.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PortalSessionExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.create_session(
            customer_id="cust_dev_abc123",
            return_url="http://example.com/account",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "billing_portal/sessions",
            method="POST",
            json={"customer_id": customer_id, "return_url": return_url},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PortalSessionExternal, construct_type(type_=PortalSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_billing_summary(
        self, secure_token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BillingSummaryExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BillingSummaryExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.get_billing_summary(
            secure_token="secure_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/summary/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(BillingSummaryExternal, construct_type(type_=BillingSummaryExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_invoices(
        self,
        secure_token: str,
        *,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        status: typing.Optional[InvoiceStatusEnum] = OMIT,
        subscription_id: typing.Optional[str] = OMIT,
        billing_reason: typing.Optional[BillingReasonEnum] = OMIT,
        total_amount_atom: typing.Optional[IntRangeFilter] = OMIT,
        period_start: typing.Optional[DateTimeFilter] = OMIT,
        period_end: typing.Optional[DateTimeFilter] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListResponseInvoiceExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        customer_id : typing.Optional[str]
            Unique identifier of the customer.

        status : typing.Optional[InvoiceStatusEnum]
            Status of invoice.

        subscription_id : typing.Optional[str]
            Unique identifier of the subscription.

        billing_reason : typing.Optional[BillingReasonEnum]
            Indicates the reason why the invoice was created.

        total_amount_atom : typing.Optional[IntRangeFilter]
            This contains fields used for range filters on total_amount_atom field.

        period_start : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period starting dates. Includes options for equality, and greater than/less than comparisons.

        period_end : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period ending dates. Includes options for equality, and greater than/less than comparisons.

        coupon_id : typing.Optional[str]
            Coupon id which is applied to an invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseInvoiceExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.list_invoices(
            secure_token="secure_token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/invoices/",
            method="POST",
            json={
                "page_number": page_number,
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "customer_id": customer_id,
                "status": status,
                "subscription_id": subscription_id,
                "billing_reason": billing_reason,
                "total_amount_atom": total_amount_atom,
                "period_start": period_start,
                "period_end": period_end,
                "coupon_id": coupon_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def detach_payment_method(
        self, secure_token: str, payment_method_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PaymentMethodExternal:
        """
        Detaches payment_method from a customer, for use by the billing portal.

        A detached payment method can no longer be used for payment,
        nor can it be reattached to the same or a different customer.

        A payment method cannot be detached if it is the default payment
        method for at least one customer, invoice, or active subscription.

        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        payment_method_id : str
            Unique Identifier of the payment_method.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaymentMethodExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.detach_payment_method(
            secure_token="secure_token",
            payment_method_id="payment_method_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/payment_methods/{jsonable_encoder(payment_method_id)}/detach/",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PaymentMethodExternal, construct_type(type_=PaymentMethodExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_subscription(
        self,
        secure_token: str,
        subscription_id: str,
        *,
        request: typing.Optional[DeleteSubscriptionRequest] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        request : typing.Optional[DeleteSubscriptionRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.delete_subscription(
            secure_token="secure_token",
            subscription_id="subscription_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionExternal, construct_type(type_=SubscriptionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_subscription(
        self,
        secure_token: str,
        subscription_id: str,
        mode: UpdateMode,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        cancel_at_end: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        trial_end: typing.Optional[dt.datetime] = OMIT,
        trial_period_days: typing.Optional[int] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        promotion_code_id: typing.Optional[str] = OMIT,
        items: typing.Optional[typing.Sequence[InlineSubscriptionItemUpdate]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateSubscriptionPublicResponse:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        mode : UpdateMode
            Whether to do a preview, or to apply the actual update. Can have the values "preview" and "apply".

        payment_method_id : typing.Optional[str]
            ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.

        cancel_at_end : typing.Optional[bool]
            Boolean indicating whether this subscription should cancel at the end of the current period.

        description : typing.Optional[str]
            Arbitrary String describing this subscription.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes

        trial_end : typing.Optional[dt.datetime]
            ISO datetime representing the end of the trial period the customer will get before being charged for the first time. The operation is only allowed for currently trialing subscriptions

        trial_period_days : typing.Optional[int]
            Integer representing the number of trial period days before the customer is charged for the first time. This are additional days from now, and overwrites current trial_end. The operation is only allowed for currently trialing subscriptions

        coupon_id : typing.Optional[str]
            The ID of the coupon to apply to this subscription. The coupon will also be applied to any subscriptions spawned during update call.

        promotion_code_id : typing.Optional[str]
            The API ID of a promotion code to apply to this subscription. The promotion code will also be applied to any subscriptions spawned during update call.

        items : typing.Optional[typing.Sequence[InlineSubscriptionItemUpdate]]
            A list of up to 20 subscription items, each with an attached price.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateSubscriptionPublicResponse
            Successful Response

        Examples
        --------
        from openpay import UpdateMode
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.update_subscription(
            secure_token="secure_token",
            subscription_id="subscription_id",
            mode=UpdateMode.PREVIEW,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/subscriptions/{jsonable_encoder(subscription_id)}/{jsonable_encoder(mode)}",
            method="PUT",
            json={
                "payment_method_id": payment_method_id,
                "cancel_at_end": cancel_at_end,
                "description": description,
                "proration_behavior": proration_behavior,
                "trial_end": trial_end,
                "trial_period_days": trial_period_days,
                "coupon_id": coupon_id,
                "promotion_code_id": promotion_code_id,
                "items": items,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UpdateSubscriptionPublicResponse, construct_type(type_=UpdateSubscriptionPublicResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_possible_prices_for_subscription_public(
        self, secure_token: str, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PricesForSubscriptionResponse:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PricesForSubscriptionResponse
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.billing_portal.get_possible_prices_for_subscription_public(
            secure_token="secure_token",
            subscription_id="subscription_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/get_possible_prices_for_subscription/{jsonable_encoder(subscription_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PricesForSubscriptionResponse, construct_type(type_=PricesForSubscriptionResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncBillingPortalClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_session(
        self, *, customer_id: str, return_url: str, request_options: typing.Optional[RequestOptions] = None
    ) -> PortalSessionExternal:
        """
        Parameters
        ----------
        customer_id : str
            The ID of an existing customer.

        return_url : str
            The default URL to redirect customers to when they click on the portal's link to return to your website.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PortalSessionExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.create_session(
                customer_id="cust_dev_abc123",
                return_url="http://example.com/account",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "billing_portal/sessions",
            method="POST",
            json={"customer_id": customer_id, "return_url": return_url},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PortalSessionExternal, construct_type(type_=PortalSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_billing_summary(
        self, secure_token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BillingSummaryExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BillingSummaryExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.get_billing_summary(
                secure_token="secure_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/summary/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(BillingSummaryExternal, construct_type(type_=BillingSummaryExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_invoices(
        self,
        secure_token: str,
        *,
        page_number: typing.Optional[int] = OMIT,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        status: typing.Optional[InvoiceStatusEnum] = OMIT,
        subscription_id: typing.Optional[str] = OMIT,
        billing_reason: typing.Optional[BillingReasonEnum] = OMIT,
        total_amount_atom: typing.Optional[IntRangeFilter] = OMIT,
        period_start: typing.Optional[DateTimeFilter] = OMIT,
        period_end: typing.Optional[DateTimeFilter] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListResponseInvoiceExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        page_number : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        customer_id : typing.Optional[str]
            Unique identifier of the customer.

        status : typing.Optional[InvoiceStatusEnum]
            Status of invoice.

        subscription_id : typing.Optional[str]
            Unique identifier of the subscription.

        billing_reason : typing.Optional[BillingReasonEnum]
            Indicates the reason why the invoice was created.

        total_amount_atom : typing.Optional[IntRangeFilter]
            This contains fields used for range filters on total_amount_atom field.

        period_start : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period starting dates. Includes options for equality, and greater than/less than comparisons.

        period_end : typing.Optional[DateTimeFilter]
            Filter for selecting invoices based on the range of period ending dates. Includes options for equality, and greater than/less than comparisons.

        coupon_id : typing.Optional[str]
            Coupon id which is applied to an invoice.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseInvoiceExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.list_invoices(
                secure_token="secure_token",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/invoices/",
            method="POST",
            json={
                "page_number": page_number,
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "customer_id": customer_id,
                "status": status,
                "subscription_id": subscription_id,
                "billing_reason": billing_reason,
                "total_amount_atom": total_amount_atom,
                "period_start": period_start,
                "period_end": period_end,
                "coupon_id": coupon_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseInvoiceExternal, construct_type(type_=ListResponseInvoiceExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def detach_payment_method(
        self, secure_token: str, payment_method_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PaymentMethodExternal:
        """
        Detaches payment_method from a customer, for use by the billing portal.

        A detached payment method can no longer be used for payment,
        nor can it be reattached to the same or a different customer.

        A payment method cannot be detached if it is the default payment
        method for at least one customer, invoice, or active subscription.

        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        payment_method_id : str
            Unique Identifier of the payment_method.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaymentMethodExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.detach_payment_method(
                secure_token="secure_token",
                payment_method_id="payment_method_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/payment_methods/{jsonable_encoder(payment_method_id)}/detach/",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PaymentMethodExternal, construct_type(type_=PaymentMethodExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_subscription(
        self,
        secure_token: str,
        subscription_id: str,
        *,
        request: typing.Optional[DeleteSubscriptionRequest] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionExternal:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        request : typing.Optional[DeleteSubscriptionRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.delete_subscription(
                secure_token="secure_token",
                subscription_id="subscription_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/subscriptions/{jsonable_encoder(subscription_id)}",
            method="DELETE",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionExternal, construct_type(type_=SubscriptionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_subscription(
        self,
        secure_token: str,
        subscription_id: str,
        mode: UpdateMode,
        *,
        payment_method_id: typing.Optional[str] = OMIT,
        cancel_at_end: typing.Optional[bool] = OMIT,
        description: typing.Optional[str] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        trial_end: typing.Optional[dt.datetime] = OMIT,
        trial_period_days: typing.Optional[int] = OMIT,
        coupon_id: typing.Optional[str] = OMIT,
        promotion_code_id: typing.Optional[str] = OMIT,
        items: typing.Optional[typing.Sequence[InlineSubscriptionItemUpdate]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateSubscriptionPublicResponse:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        mode : UpdateMode
            Whether to do a preview, or to apply the actual update. Can have the values "preview" and "apply".

        payment_method_id : typing.Optional[str]
            ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.

        cancel_at_end : typing.Optional[bool]
            Boolean indicating whether this subscription should cancel at the end of the current period.

        description : typing.Optional[str]
            Arbitrary String describing this subscription.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes

        trial_end : typing.Optional[dt.datetime]
            ISO datetime representing the end of the trial period the customer will get before being charged for the first time. The operation is only allowed for currently trialing subscriptions

        trial_period_days : typing.Optional[int]
            Integer representing the number of trial period days before the customer is charged for the first time. This are additional days from now, and overwrites current trial_end. The operation is only allowed for currently trialing subscriptions

        coupon_id : typing.Optional[str]
            The ID of the coupon to apply to this subscription. The coupon will also be applied to any subscriptions spawned during update call.

        promotion_code_id : typing.Optional[str]
            The API ID of a promotion code to apply to this subscription. The promotion code will also be applied to any subscriptions spawned during update call.

        items : typing.Optional[typing.Sequence[InlineSubscriptionItemUpdate]]
            A list of up to 20 subscription items, each with an attached price.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateSubscriptionPublicResponse
            Successful Response

        Examples
        --------
        import asyncio

        from openpay import UpdateMode
        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.update_subscription(
                secure_token="secure_token",
                subscription_id="subscription_id",
                mode=UpdateMode.PREVIEW,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/subscriptions/{jsonable_encoder(subscription_id)}/{jsonable_encoder(mode)}",
            method="PUT",
            json={
                "payment_method_id": payment_method_id,
                "cancel_at_end": cancel_at_end,
                "description": description,
                "proration_behavior": proration_behavior,
                "trial_end": trial_end,
                "trial_period_days": trial_period_days,
                "coupon_id": coupon_id,
                "promotion_code_id": promotion_code_id,
                "items": items,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UpdateSubscriptionPublicResponse, construct_type(type_=UpdateSubscriptionPublicResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_possible_prices_for_subscription_public(
        self, secure_token: str, subscription_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> PricesForSubscriptionResponse:
        """
        Parameters
        ----------
        secure_token : str
            Secure token of the portal session.

        subscription_id : str
            Unique identifier of the subscription.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PricesForSubscriptionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.billing_portal.get_possible_prices_for_subscription_public(
                secure_token="secure_token",
                subscription_id="subscription_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"billing_portal/public/{jsonable_encoder(secure_token)}/get_possible_prices_for_subscription/{jsonable_encoder(subscription_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PricesForSubscriptionResponse, construct_type(type_=PricesForSubscriptionResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
