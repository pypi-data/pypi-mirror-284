# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.checkout_mode import CheckoutMode
from ..types.checkout_session_external import CheckoutSessionExternal
from ..types.create_checkout_line_item import CreateCheckoutLineItem
from ..types.currency_enum import CurrencyEnum
from ..types.date_time_filter import DateTimeFilter
from ..types.http_validation_error import HttpValidationError
from ..types.list_response_checkout_session_external import ListResponseCheckoutSessionExternal

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CheckoutClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_session(
        self,
        *,
        mode: CheckoutMode,
        client_reference_id: typing.Optional[str] = OMIT,
        currency: typing.Optional[CurrencyEnum] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        customer_email: typing.Optional[str] = OMIT,
        line_items: typing.Optional[typing.Sequence[CreateCheckoutLineItem]] = OMIT,
        return_url: typing.Optional[str] = OMIT,
        success_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CheckoutSessionExternal:
        """
        Parameters
        ----------
        mode : CheckoutMode
            The mode of the Checkout Session. Possible values: payment (one-time payments), setup (not supported yet), subscription (recurring payments).

        client_reference_id : typing.Optional[str]
            A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the Session with your internal systems.

        currency : typing.Optional[CurrencyEnum]
            Three-letter ISO currency code, in lowercase. Only applicable in setup mode.

        customer_id : typing.Optional[str]
            ID of an existing Customer, if one exists. The customer will be created if no ID is supplied.

        customer_email : typing.Optional[str]
            If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.

        line_items : typing.Optional[typing.Sequence[CreateCheckoutLineItem]]
            The line items purchased by the customer.

        return_url : typing.Optional[str]
            The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. This parameter is required if ui_mode is embedded and redirect-based payment methods are enabled on the session.

        success_url : typing.Optional[str]
            The URL to which OpenPay should send customers when payment or setup is complete. This parameter is not allowed if ui_mode is embedded.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CheckoutSessionExternal
            Successful Response

        Examples
        --------
        from openpay import CheckoutMode
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.checkout.create_session(
            mode=CheckoutMode.PAYMENT,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "checkout/sessions",
            method="POST",
            json={
                "client_reference_id": client_reference_id,
                "currency": currency,
                "customer_id": customer_id,
                "customer_email": customer_email,
                "line_items": line_items,
                "mode": mode,
                "return_url": return_url,
                "success_url": success_url,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CheckoutSessionExternal, construct_type(type_=CheckoutSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_session(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CheckoutSessionExternal:
        """
        Parameters
        ----------
        session_id : str
            Unique identifier of the checkout session.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CheckoutSessionExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.checkout.get_session(
            session_id="session_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"checkout/sessions/{jsonable_encoder(session_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CheckoutSessionExternal, construct_type(type_=CheckoutSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self,
        *,
        page_number: typing.Optional[int] = None,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        payment_link_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[CheckoutSessionExternal]:
        """
        Parameters
        ----------
        page_number : typing.Optional[int]

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        payment_link_id : typing.Optional[str]
            Filter charges by payment link ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[CheckoutSessionExternal]
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        response = client.checkout.list()
        for item in response:
            yield item
        # alternatively, you can paginate page-by-page
        for page in response.iter_pages():
            yield page
        """
        page_number = page_number if page_number is not None else 1
        _response = self._client_wrapper.httpx_client.request(
            "checkout/list",
            method="POST",
            params={"page_number": page_number},
            json={
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "payment_link_id": payment_link_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListResponseCheckoutSessionExternal, construct_type(type_=ListResponseCheckoutSessionExternal, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page_number=page_number + 1,
                    page_size=page_size,
                    sort_key=sort_key,
                    sort_descending=sort_descending,
                    created_at=created_at,
                    expand=expand,
                    payment_link_id=payment_link_id,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCheckoutClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_session(
        self,
        *,
        mode: CheckoutMode,
        client_reference_id: typing.Optional[str] = OMIT,
        currency: typing.Optional[CurrencyEnum] = OMIT,
        customer_id: typing.Optional[str] = OMIT,
        customer_email: typing.Optional[str] = OMIT,
        line_items: typing.Optional[typing.Sequence[CreateCheckoutLineItem]] = OMIT,
        return_url: typing.Optional[str] = OMIT,
        success_url: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CheckoutSessionExternal:
        """
        Parameters
        ----------
        mode : CheckoutMode
            The mode of the Checkout Session. Possible values: payment (one-time payments), setup (not supported yet), subscription (recurring payments).

        client_reference_id : typing.Optional[str]
            A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the Session with your internal systems.

        currency : typing.Optional[CurrencyEnum]
            Three-letter ISO currency code, in lowercase. Only applicable in setup mode.

        customer_id : typing.Optional[str]
            ID of an existing Customer, if one exists. The customer will be created if no ID is supplied.

        customer_email : typing.Optional[str]
            If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the customer field.

        line_items : typing.Optional[typing.Sequence[CreateCheckoutLineItem]]
            The line items purchased by the customer.

        return_url : typing.Optional[str]
            The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. This parameter is required if ui_mode is embedded and redirect-based payment methods are enabled on the session.

        success_url : typing.Optional[str]
            The URL to which OpenPay should send customers when payment or setup is complete. This parameter is not allowed if ui_mode is embedded.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CheckoutSessionExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay import CheckoutMode
        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.checkout.create_session(
                mode=CheckoutMode.PAYMENT,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "checkout/sessions",
            method="POST",
            json={
                "client_reference_id": client_reference_id,
                "currency": currency,
                "customer_id": customer_id,
                "customer_email": customer_email,
                "line_items": line_items,
                "mode": mode,
                "return_url": return_url,
                "success_url": success_url,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CheckoutSessionExternal, construct_type(type_=CheckoutSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_session(
        self, session_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CheckoutSessionExternal:
        """
        Parameters
        ----------
        session_id : str
            Unique identifier of the checkout session.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CheckoutSessionExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.checkout.get_session(
                session_id="session_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"checkout/sessions/{jsonable_encoder(session_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CheckoutSessionExternal, construct_type(type_=CheckoutSessionExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self,
        *,
        page_number: typing.Optional[int] = None,
        page_size: typing.Optional[int] = OMIT,
        sort_key: typing.Optional[str] = OMIT,
        sort_descending: typing.Optional[bool] = OMIT,
        created_at: typing.Optional[DateTimeFilter] = OMIT,
        expand: typing.Optional[typing.Sequence[str]] = OMIT,
        payment_link_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[CheckoutSessionExternal]:
        """
        Parameters
        ----------
        page_number : typing.Optional[int]

        page_size : typing.Optional[int]
            Page size

        sort_key : typing.Optional[str]
            Key name based on which data is sorted.

        sort_descending : typing.Optional[bool]
            Sort direction.

        created_at : typing.Optional[DateTimeFilter]
            Filter for selecting objects based on the range of creation dates. Includes options for equality, and greater than/less than comparisons.

        expand : typing.Optional[typing.Sequence[str]]
            Specifies which fields in the response should be expanded.

        payment_link_id : typing.Optional[str]
            Filter charges by payment link ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[CheckoutSessionExternal]
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            response = await client.checkout.list()
            async for item in response:
                yield item
            # alternatively, you can paginate page-by-page
            async for page in response.iter_pages():
                yield page


        asyncio.run(main())
        """
        page_number = page_number if page_number is not None else 1
        _response = await self._client_wrapper.httpx_client.request(
            "checkout/list",
            method="POST",
            params={"page_number": page_number},
            json={
                "page_size": page_size,
                "sort_key": sort_key,
                "sort_descending": sort_descending,
                "created_at": created_at,
                "expand": expand,
                "payment_link_id": payment_link_id,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(ListResponseCheckoutSessionExternal, construct_type(type_=ListResponseCheckoutSessionExternal, object_=_response.json()))  # type: ignore
                _has_next = True
                _get_next = lambda: self.list(
                    page_number=page_number + 1,
                    page_size=page_size,
                    sort_key=sort_key,
                    sort_descending=sort_descending,
                    created_at=created_at,
                    expand=expand,
                    payment_link_id=payment_link_id,
                    request_options=request_options,
                )
                _items = _parsed_response.data
                return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
