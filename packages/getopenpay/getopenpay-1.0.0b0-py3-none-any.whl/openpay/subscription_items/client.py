# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.delete_subscription_item_response import DeleteSubscriptionItemResponse
from ..types.http_validation_error import HttpValidationError
from ..types.list_response_subscription_item_external import ListResponseSubscriptionItemExternal
from ..types.proration_enum import ProrationEnum
from ..types.subscription_item_external import SubscriptionItemExternal

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SubscriptionItemsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self, *, subscription_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ListResponseSubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_id : str
            The ID of the subscription whose items will be retrieved.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseSubscriptionItemExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.subscription_items.list(
            subscription_id="subi_dev_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "subscription-items/list",
            method="POST",
            json={"subscription_id": subscription_id},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseSubscriptionItemExternal, construct_type(type_=ListResponseSubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.subscription_items.get(
            subscription_item_id="subscription_item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        subscription_item_id: str,
        *,
        price_id: typing.Optional[str] = OMIT,
        quantity: typing.Optional[int] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        drop_at_end: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        price_id : typing.Optional[str]
            The ID of the price. When changing a subscription item’s price, quantity is set to 1 unless a quantity parameter is provided.

        quantity : typing.Optional[int]
            The quantity you’d like to apply to the subscription item you’re updating.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        drop_at_end : typing.Optional[bool]
            A flag that, if set to true, will drop the subscription item from subscription when renewing subscription. delete flag can not be used while using this behaviour

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.subscription_items.update(
            subscription_item_id="subscription_item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="PUT",
            json={
                "price_id": price_id,
                "quantity": quantity,
                "proration_behavior": proration_behavior,
                "drop_at_end": drop_at_end,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(
        self,
        subscription_item_id: str,
        *,
        drop_at_end: typing.Optional[bool] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeleteSubscriptionItemResponse:
        """
        Deletes an item from the subscription. Removing a subscription item
        from a subscription will not cancel the subscription.
        Default behaviour is to remove the subscription item at time of
        renewing the subscription at next billing cycle. You can override
        the behaviour by setting cancel_at_end as False.
        After successful call to this method with drop_at_end as True,
        if you want to clear the flag, use update call with drop_at_end as False.

        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        drop_at_end : typing.Optional[bool]
            Whether or not this item will be dropped from subscription before next renewal

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations while deleting item.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteSubscriptionItemResponse
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.subscription_items.delete(
            subscription_item_id="subscription_item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="DELETE",
            json={"drop_at_end": drop_at_end, "proration_behavior": proration_behavior},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(DeleteSubscriptionItemResponse, construct_type(type_=DeleteSubscriptionItemResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        subscription_id: str,
        price_id: str,
        add_at_period_end: typing.Optional[bool] = OMIT,
        quantity: typing.Optional[int] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionItemExternal:
        """
        Adds a new item to an existing subscription. No existing items will be changed or replaced.

        Parameters
        ----------
        subscription_id : str
            The identifier of the subscription to modify

        price_id : str
            The ID of the price.

        add_at_period_end : typing.Optional[bool]
            If the flag is set to True, item will be added when renewing the subscription at next billing cycle.

        quantity : typing.Optional[int]
            The quantity you’d like to apply to the subscription item you’re creating.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.subscription_items.create(
            subscription_id="subi_dev_abc123",
            price_id="price_dev_abc123",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "subscription-items/",
            method="POST",
            json={
                "subscription_id": subscription_id,
                "add_at_period_end": add_at_period_end,
                "price_id": price_id,
                "quantity": quantity,
                "proration_behavior": proration_behavior,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSubscriptionItemsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self, *, subscription_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> ListResponseSubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_id : str
            The ID of the subscription whose items will be retrieved.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListResponseSubscriptionItemExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.subscription_items.list(
                subscription_id="subi_dev_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "subscription-items/list",
            method="POST",
            json={"subscription_id": subscription_id},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListResponseSubscriptionItemExternal, construct_type(type_=ListResponseSubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.subscription_items.get(
                subscription_item_id="subscription_item_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        subscription_item_id: str,
        *,
        price_id: typing.Optional[str] = OMIT,
        quantity: typing.Optional[int] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        drop_at_end: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionItemExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        price_id : typing.Optional[str]
            The ID of the price. When changing a subscription item’s price, quantity is set to 1 unless a quantity parameter is provided.

        quantity : typing.Optional[int]
            The quantity you’d like to apply to the subscription item you’re updating.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        drop_at_end : typing.Optional[bool]
            A flag that, if set to true, will drop the subscription item from subscription when renewing subscription. delete flag can not be used while using this behaviour

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.subscription_items.update(
                subscription_item_id="subscription_item_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="PUT",
            json={
                "price_id": price_id,
                "quantity": quantity,
                "proration_behavior": proration_behavior,
                "drop_at_end": drop_at_end,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(
        self,
        subscription_item_id: str,
        *,
        drop_at_end: typing.Optional[bool] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> DeleteSubscriptionItemResponse:
        """
        Deletes an item from the subscription. Removing a subscription item
        from a subscription will not cancel the subscription.
        Default behaviour is to remove the subscription item at time of
        renewing the subscription at next billing cycle. You can override
        the behaviour by setting cancel_at_end as False.
        After successful call to this method with drop_at_end as True,
        if you want to clear the flag, use update call with drop_at_end as False.

        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        drop_at_end : typing.Optional[bool]
            Whether or not this item will be dropped from subscription before next renewal

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations while deleting item.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DeleteSubscriptionItemResponse
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.subscription_items.delete(
                subscription_item_id="subscription_item_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}",
            method="DELETE",
            json={"drop_at_end": drop_at_end, "proration_behavior": proration_behavior},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(DeleteSubscriptionItemResponse, construct_type(type_=DeleteSubscriptionItemResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        subscription_id: str,
        price_id: str,
        add_at_period_end: typing.Optional[bool] = OMIT,
        quantity: typing.Optional[int] = OMIT,
        proration_behavior: typing.Optional[ProrationEnum] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SubscriptionItemExternal:
        """
        Adds a new item to an existing subscription. No existing items will be changed or replaced.

        Parameters
        ----------
        subscription_id : str
            The identifier of the subscription to modify

        price_id : str
            The ID of the price.

        add_at_period_end : typing.Optional[bool]
            If the flag is set to True, item will be added when renewing the subscription at next billing cycle.

        quantity : typing.Optional[int]
            The quantity you’d like to apply to the subscription item you’re creating.

        proration_behavior : typing.Optional[ProrationEnum]
            Determines how to handle prorations when the billable items changes.In case of subscription is in trialing state, invoice items if any will be for amount_atom 0.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SubscriptionItemExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.subscription_items.create(
                subscription_id="subi_dev_abc123",
                price_id="price_dev_abc123",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "subscription-items/",
            method="POST",
            json={
                "subscription_id": subscription_id,
                "add_at_period_end": add_at_period_end,
                "price_id": price_id,
                "quantity": quantity,
                "proration_behavior": proration_behavior,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(SubscriptionItemExternal, construct_type(type_=SubscriptionItemExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
