# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from ..types.usage_record_action import UsageRecordAction
from ..types.user_record_external import UserRecordExternal
from ..types.user_record_summary_external import UserRecordSummaryExternal

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class UsageRecordsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_summaries(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[UserRecordSummaryExternal]:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[UserRecordSummaryExternal]
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.usage_records.get_summaries(
            subscription_item_id="subscription_item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-record-summaries",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[UserRecordSummaryExternal], construct_type(type_=typing.List[UserRecordSummaryExternal], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[UserRecordExternal]:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[UserRecordExternal]
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.usage_records.get(
            subscription_item_id="subscription_item_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-records",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[UserRecordExternal], construct_type(type_=typing.List[UserRecordExternal], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        subscription_item_id: str,
        *,
        quantity: int,
        usage_datetime: typing.Optional[dt.datetime] = OMIT,
        action: typing.Optional[UsageRecordAction] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserRecordExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        quantity : int
            The usage quantity for the specified timestamp.

        usage_datetime : typing.Optional[dt.datetime]
            The datetime for the usage event. This datetime must be within the current billing period of the subscription of the provided subscription_item, and must not be in the future. Default is 'now' if a value is not provided.This should not be for a datetime that we have already invoiced, else the request will notfail but we will not be able to include it in invoiced period.

        action : typing.Optional[UsageRecordAction]
            When using increment the specified quantity will be added to the usage at the specified datetime. The set action will overwrite the usage quantity at that datetime. If the subscription has billing thresholds, increment is the only allowed value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserRecordExternal
            Successful Response

        Examples
        --------
        from openpay.client import OpenPay

        client = OpenPay(
            token="YOUR_TOKEN",
        )
        client.usage_records.create(
            subscription_item_id="subscription_item_id",
            quantity=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-records",
            method="POST",
            json={"quantity": quantity, "usage_datetime": usage_datetime, "action": action},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UserRecordExternal, construct_type(type_=UserRecordExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncUsageRecordsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_summaries(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[UserRecordSummaryExternal]:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[UserRecordSummaryExternal]
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.usage_records.get_summaries(
                subscription_item_id="subscription_item_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-record-summaries",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[UserRecordSummaryExternal], construct_type(type_=typing.List[UserRecordSummaryExternal], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, subscription_item_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[UserRecordExternal]:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[UserRecordExternal]
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.usage_records.get(
                subscription_item_id="subscription_item_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-records",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(typing.List[UserRecordExternal], construct_type(type_=typing.List[UserRecordExternal], object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        subscription_item_id: str,
        *,
        quantity: int,
        usage_datetime: typing.Optional[dt.datetime] = OMIT,
        action: typing.Optional[UsageRecordAction] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UserRecordExternal:
        """
        Parameters
        ----------
        subscription_item_id : str
            Unique identifier of the subscription_item.

        quantity : int
            The usage quantity for the specified timestamp.

        usage_datetime : typing.Optional[dt.datetime]
            The datetime for the usage event. This datetime must be within the current billing period of the subscription of the provided subscription_item, and must not be in the future. Default is 'now' if a value is not provided.This should not be for a datetime that we have already invoiced, else the request will notfail but we will not be able to include it in invoiced period.

        action : typing.Optional[UsageRecordAction]
            When using increment the specified quantity will be added to the usage at the specified datetime. The set action will overwrite the usage quantity at that datetime. If the subscription has billing thresholds, increment is the only allowed value.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UserRecordExternal
            Successful Response

        Examples
        --------
        import asyncio

        from openpay.client import AsyncOpenPay

        client = AsyncOpenPay(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.usage_records.create(
                subscription_item_id="subscription_item_id",
                quantity=1,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"subscription-items/{jsonable_encoder(subscription_item_id)}/usage-records",
            method="POST",
            json={"quantity": quantity, "usage_datetime": usage_datetime, "action": action},
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UserRecordExternal, construct_type(type_=UserRecordExternal, object_=_response.json()))  # type: ignore
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(HttpValidationError, construct_type(type_=HttpValidationError, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
